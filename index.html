<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="color-scheme" content="light dark">
    <title>PrismV - 당신의 단어를 기록하세요</title>
    <meta name="referrer" content="no-referrer">

    <!-- PWA Settings -->
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a3a">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Poppins:wght@400;600&display=swap"
        rel="stylesheet">

    <style>
        :root {
            /* ShiftV Color Palette */
            --bg-main: #1a1a3a;
            --primary: #ff8fcd;
            --accent: #ff60a8;
            --danger: #ff5577;
            --text-main: #f0f0ff;
            --text-dim: #a8a8d8;
            --glass-bg: rgba(42, 42, 98, 0.4);
            --glass-border: rgba(180, 180, 255, 0.2);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.25);
            --glass-blur: 12px;
            --bg-dimbox: rgba(81, 81, 187, 0.2);
            --radius-xl: 30px;
            --radius-l: 20px;
            --radius-m: 15px;
            --radius-s: 10px;
            --ios-slider: rgba(255, 255, 255, 0.2);

            --grad-dark: linear-gradient(135deg, #1e1e48 0%, #2a2a60 50%, #151532 100%);
            --grad-light: linear-gradient(160deg, #fdeef5 0%, #dfe9f3 100%);

            --bg-gradient-dark: linear-gradient(135deg, #1e1e48 0%, #2a2a60 50%, #151532 100%);
            --input-bg: rgba(255, 255, 255, 0.05);

            --tab-height-mobile: 65px;
            --tab-width-desktop: 250px;
            --stat-widget: rgba(35, 15, 69, 0.2);
            --header-collapsed-height: 80px;
            /* 헤더 최소 높이 고정 */
            --header-expanded-height: auto;
            /* 사이드바 넓이 */
        }

        body.light-mode {
            --bg-main: #fdeef5;
            --bg-gradient-dark: linear-gradient(160deg, #fdeef5 0%, #dfe9f3 100%);
            --text-main: #2c2c58;
            --text-dim: #525273;
            --primary: #ff6ba9;
            --accent: #e04f84;
            --danger: #ee5253;
            --bg-dimbox: rgba(255, 205, 231, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(0, 0, 0, 0.08);
            --ios-slider: rgba(255, 255, 255, 0.4);
            /* 밝은 테두리 */
            --glass-shadow: 0 8px 32px rgba(155, 93, 123, 0.2);
            --header-bg: rgba(255, 255, 255, 0.9);
            /* 라이트 헤더는 밝고 불투명하게 */
            --header-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
            --card-bg: rgba(0, 0, 0, 0.03);
            /* 아주 연한 회색 배경 */

            --input-bg: rgba(255, 255, 255, 1);

            --stat-widget: rgba(255, 248, 251, 0.4);
            --bg-gradient: linear-gradient(135deg, #faf5f7 0%, #e2c3d1 100%);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* --- [CSS 수정] body 배경 전환 애니메이션 오류 해결 --- */
        body {
            font-family: 'Poppins', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Hiragino Sans", "Hiragino Kaku Gothic ProN", "Biaodian Pro Sans", "Meiryo", sans-serif;
            margin: 0;

            /* [핵심 수정] body에는 배경색만 지정하고 그라데이션은 제거 */
            background-color: var(--bg-main);
            color: var(--text-main);

            height: 100vh;
            overflow: hidden;

            /* 색상 변경 애니메이션 */
            transition: background-color 0.5s ease, color 0.5s ease;
            user-select: none;

            /* 가상 요소를 위한 포지셔닝 컨텍스트 */
            position: relative;
            z-index: 0;
        }

        /* [신규] 다크 모드용 그라데이션 레이어 (기본 보임) */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--grad-dark);
            z-index: -2;
            /* 맨 뒤 */
            opacity: 1;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        /* [신규] 라이트 모드용 그라데이션 레이어 (기본 숨김) */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--grad-light);
            z-index: -1;
            /* 다크 레이어 바로 앞 */
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        /* [핵심] 라이트 모드 클래스가 붙으면 투명도를 교차시킴 (Cross-fade) */
        body.light-mode::before {
            opacity: 0;
            /* 다크 배경 숨김 */
        }

        body.light-mode::after {
            opacity: 1;
            /* 라이트 배경 보임 */
        }

        /* --- [NEW] Layout & Header System (Anti-Jitter) --- */
        /* 메인 레이아웃 (스크롤 영역 분리를 위함) */
        .app-wrapper {
            display: flex;
            height: 100vh;
            width: 100%;
            overflow: hidden;
        }


        /* 컨텐츠 영역: 전체 화면에서 사이드바 뺀 나머지 */
        .container {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0 20px;
            padding-top: 30px !important;
            box-sizing: border-box;
            /* 기존 padding 20px 제거 */
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .container.no-scroll {
            overflow: hidden !important;
        }

        .stat-widget-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        h2 {
            color: var(--primary);
            font-size: 1.5rem;
            margin: 0 0 20px 0;
        }

        h3 {
            color: var(--accent);
            font-size: 1.2rem;
            margin: 20px 0 10px 0;
        }

        p.desc {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-top: -10px;
            margin-bottom: 20px;
        }

        /* --- Glass Components --- */
        .glass-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-l);
            padding: 20px;
            box-shadow: var(--glass-shadow);
            backdrop-filter: blur(var(--glass-blur));
            margin-bottom: 0px;
            transition: 0.3s;
        }




        /* --- [CSS 수정] 슬림하고 둥근 사이드바 (Floating Slim) --- */
        .tab-bar {
            /* [수정] 너비를 56px로 줄여서 가시성 확보 */
            width: 52px;
            height: calc(100vh - 30px);
            margin: 15px 0 15px 10px;
            /* 왼쪽 여백 살짝 줄임 */

            /* 둥근 모서리 (너비의 절반) */
            border-radius: 28px;

            /* 배경 및 유리 효과 */
            background: rgba(20, 20, 35, 0.75);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);

            /* 테두리 및 그림자 */
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);

            /* 내부 정렬 */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 25px;
            padding-bottom: 20px;
            gap: 15px;
            /* 버튼 간격 좁힘 */

            flex-shrink: 0;
            /* 사이드바가 찌그러지지 않게 고정 */
            z-index: 100;
        }

        /* 라이트 모드 */
        body.light-mode .tab-bar {
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        @keyframes tabActivate {
            0% {
                transform: scale(1);
            }

            40% {
                transform: scale(0.8);
                /* 꾹 눌리는 느낌 (작아짐) */
            }

            100% {
                transform: scale(1.1);
                /* 최종적으로 살짝 커진 상태 */
            }
        }

        .tab-button {
            /* [핵심 수정 1] 기본 크기 설정 */
            width: 60px;
            height: 60px;

            /* [핵심 수정 2] 절대 줄어들지 않도록 최소 크기 강제 고정 */
            min-width: 60px;
            min-height: 60px;

            /* [핵심 수정 3] 플렉스 컨테이너 안에서 수축 방지 */
            flex-shrink: 0;

            background: transparent;
            border: 1px solid transparent;
            border-radius: 50%;
            /* 완전한 원형 */
            color: var(--text-dim);
            cursor: pointer;

            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;

            position: relative;
            /* 리퀴드 효과가 둥근 버튼 밖으로 나가지 않게 함 */
            overflow: hidden;
            transition: all 0.4s ease;
            z-index: 1;
        }

        /* 호버 효과 */
        .tab-button:hover {
            color: var(--text-main);
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
            /* 호버 시에도 살짝 커짐 */
        }

        body.light-mode .tab-button:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .tab-button.active {
            /* 배경: 핑크기를 빼고 투명한 화이트 틴트로 변경 */
            background: rgba(215, 162, 255, 0.07);

            /* [Shine Layer] 내부 광택 및 그림자 조정 */
            box-shadow:
                /* 왼쪽 상단 미세한 하이라이트 (유리 두께감) */
                inset 1px 1px 2px 0 rgba(255, 255, 255, 0.4),

                /* 오른쪽 하단 반사광 (투명도 조절) */
                inset -1px -1px 2px 0 rgba(255, 255, 255, 0.1),

                /* 외부 그림자 (깊이감만 유지) */
                0 4px 10px rgba(0, 0, 0, 0.2),

                /* 외곽 글로우: 강도를 대폭 줄이고 투명하게 처리 */
                0 0 8px rgba(255, 143, 205, 0.15);

            /* 테두리: 얇고 투명하게 */
            border: 1px solid rgba(255, 255, 255, 0.15);

            color: #fff;
            /* 아이콘 흰색 */
            animation: tabActivate 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            /* 크기 변화 살짝 줄임 (1.1 -> 1.05) */
        }

        /* [가상 요소] 왜곡 효과 (그대로 유지하되 투명도만 미세 조정) */
        .tab-button.active::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;

            backdrop-filter: blur(8px);
            /* 블러를 조금 더 강화하여 매트한 느낌 */
            -webkit-backdrop-filter: blur(8px);

            filter: url(#glass-distortion);
            background: inherit;
            opacity: 0.5;
            /* 왜곡 레이어 투명도 낮춤 (너무 번들거리지 않게) */
        }

        /* 라이트 모드에서의 리퀴드 글래스 */
        body.light-mode .tab-button.active {
            background: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow:
                inset 2px 2px 5px rgba(255, 255, 255, 1),
                0 5px 15px rgba(200, 200, 200, 0.2),
                0 0 10px rgba(255, 107, 169, 0.2);
            color: var(--accent);
            animation: tabActivate 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* 아이콘 크기 및 정렬 */
        .tab-icon-area {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            position: relative;
            z-index: 2;
            /* 왜곡 레이어보다 위에 표시 */
        }

        .tab-button svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
            /* 아이콘 그림자 */
        }

        /* 이모지(국기) 크기 별도 조정 */
        .tab-button .flag-icon {
            font-size: 1.4rem !important;
            /* 국기는 조금 더 크게 */
            line-height: 1;
        }

        /* 홈 대시보드 및 통계 위젯 내의 국기 */
        .stat-widget div[style*="font-size:2.5rem"],
        /* 대시보드 국기 */
        .stat-widget div[style*="font-size:2rem"]

        /* 오답노트 아이콘 */
            {
            font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
        }

        /* 그룹 상세 헤더 등 국기 들어가는 곳 공통 */
        span {
            font-family: inherit;
            /* 기본 상속하되 필요한 곳에 위 폰트 적용됨 */
        }

        /* --- Language Tabs (Top Chips) --- */
        .lang-tabs {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            margin-bottom: 10px;
            padding-bottom: 5px;
            scrollbar-width: none;
        }

        .lang-tabs::-webkit-scrollbar {
            display: none;
        }

        .lang-chip {
            padding: 8px 16px;
            border-radius: var(--radius-xl);
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            color: var(--text-dim);
            font-size: 0.9rem;
            white-space: nowrap;
            cursor: pointer;
            transition: 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .lang-chip.active {
            background: var(--primary);
            color: #1a1a3a;
            /* Dark text for contrast */
            border-color: var(--primary);
            font-weight: bold;
        }

        .lang-chip .del-btn {
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            margin-left: 5px;
        }

        .add-lang-btn {
            background: transparent;
            border: 2px dashed var(--accent);
            color: var(--accent);
        }

        #word-items-list {
            margin: 0 auto;
            padding-bottom: 120px;
        }

        /* 호버 시 색상 살짝 변경 */

        .word-content {
            flex: 1;
            min-width: 0;
            margin-right: 10px;
        }

        .word-term {
            color: var(--text-main);
            font-weight: bold;
            font-size: 1.15rem;
        }

        .word-pron {
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: normal;
            margin-left: 8px;
        }

        .word-meaning {
            color: var(--text-dim);
            margin-top: 4px;
            font-size: 1rem;
        }


        .smart-group-container {
            position: relative;
            margin-bottom: 30px;
            padding: 0px;
        }

        .smart-group-grid {
            display: grid;
            /* 데스크탑: 150px 기준으로 꽉 채우기 */
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;

            padding: 20px;
            margin: -20px;
            width: calc(100% + 40px);

            /* 애니메이션 속성 */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            max-height: 2000px;
            /* 기본값 */
            box-sizing: border-box;
        }

        .item-left-col {
            width: 50px;
            /* PC에서는 넉넉하게 */
            min-width: 50px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            /* PC에서는 여유있게 */
        }

        /* 태블릿/모바일에서 열 개수만 강제 */
        @media (max-width: 900px) {
            .smart-group-grid {
                grid-template-columns: repeat(3, 1fr);
                /* 태블릿 3열 고정 */
            }
        }

        @media (max-width: 600px) {
            .smart-group-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                /* 모바일 2열 고정 */
            }
        }

        .expand-btn {
            width: 100%;
            padding: 12px;
            /* 버튼 위치 보정 (그리드가 10px 튀어나왔으므로 마진 조정) */
            margin-top: 20px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            color: var(--text-dim);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 25px rgba(157, 68, 102, 0.2);
            display: none;
        }

        .expand-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 6px 35px rgba(157, 68, 102, 0.2);
        }

        /* 카드 내부 텍스트 정렬 스타일 (유지) */
        .smart-card-inner {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
        }


        /* [CSS 수정] iOS 스위치 스타일 */
        .ios-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }

        .ios-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .ios-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;

            /* 기본(다크모드): 반투명 흰색 트랙 */
            background-color: rgba(255, 255, 255, 0.15);

            transition: .4s;
            border-radius: 34px;
        }

        /* ★ [여기 추가됨] 라이트 모드일 땐 트랙을 '반투명 검정(회색)'으로 변경 ★ */
        body.light-mode .ios-slider {
            background-color: rgba(0, 0, 0, 0.15);
        }

        .ios-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            /* 손잡이는 항상 흰색 */
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            /* 손잡이 그림자 추가로 가시성 확보 */
        }

        .ios-switch input:checked+.ios-slider {
            background-color: var(--primary);
            /* 켜지면 테마 색상 */
        }

        .ios-switch input:checked+.ios-slider:before {
            transform: translateX(22px);
        }

        /* Quiz Type Toggle Button */
        .q-type-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .q-type-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--glass-border);
            color: var(--text-dim);
            padding: 14px;
            border-radius: 12px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100%;
        }

        .q-type-btn:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .q-type-btn.active {
            background: rgba(255, 143, 205, 0.15);
            /* Primary color low opacity */
            border: 1px solid var(--primary);
            color: var(--text-main);
            font-weight: 600;
            box-shadow: 0 0 10px rgba(255, 143, 205, 0.1);
        }


        /* [CSS 추가] 그룹 관리 모드용 스타일 */
        .vocab-card.managing {
            border: 1px solid var(--primary);
            background: rgba(255, 255, 255, 0.08);
        }

        .group-manage-controls {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 10px;
        }

        /* 나의 단어장: 모바일 무조건 1열 (리스트 형태) */
        .my-vocab-list {
            display: flex;
            flex-direction: column;
            gap: 0px;
            padding-bottom: 80px;
            /* 하단 FAB 가려짐 방지 */
        }

        /* 단어장 카드 스타일 (리스트형에 맞게 높이 조정) */
        .vocab-card {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            min-height: 80px;
        }


        /* sub text는 흐리게 */

        .dict-btn {
            font-size: 0.85rem;
            color: #ffffff !important;
            background: linear-gradient(135deg, #03C75A, #02b350);
            /* 네이버 그린 */
            border: none;
            padding: 6px 14px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(3, 199, 90, 0.3);
            transition: 0.2s;
            white-space: nowrap;
            /* 줄바꿈 방지 */
        }

        .dict-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(3, 199, 90, 0.5);
        }

        /* --- Inputs & Forms --- */
        input,
        select,
        textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: var(--input-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-s);
            color: var(--text-main);
            font-size: 1rem;
            outline: none;
            transition: 0.3s;
        }

        input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(255, 143, 205, 0.2);
        }

        .glass-btn {
            width: 100%;
            padding: 14px;
            background: var(--glass-bg);
            border: 2px solid var(--glass-border);
            color: var(--text-main);
            border-radius: var(--radius-l);
            font-weight: 600;
            margin-top: 10px;
            cursor: pointer;
        }

        .glass-btn.primary {
            background: var(--accent);
            color: white;
            border: none;
        }


        /* --- [CSS 수정] 리퀴드 글래스 FAB (SVG 아이콘 적용) --- */
        .fab-wrapper {
            position: fixed;
            bottom: 30px;
            right: 20px;

            /* [다크모드 기본] */
            background: rgba(255, 143, 205, 0.25);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2);

            border-radius: 50px;

            /* [수정] 패딩 조절 (내부 요소 크기 0될 때 패딩만 남도록) */
            padding: 6px;

            display: flex;
            align-items: center;
            /* [중요] gap 대신 margin으로 간격 제어하여 애니메이션 시 떨림 방지 */
            gap: 0;

            z-index: 500;

            /* 전체 크기 애니메이션 */
            max-width: 140px;
            /* 넉넉하게 잡음 */
            opacity: 1;
            transform: translateY(0);
            overflow: hidden;


            /* 가속도 곡선 조정 (부드럽게 시작하고 끝남) */
            transition: max-width 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.3s ease,
                transform 0.3s ease,
                background-color 0.3s ease,
                right 0.3s ease;
        }

        /* [핵심 수정 2] 라이트 모드일 때 FAB 배경 진하게 */
        body.light-mode .fab-wrapper {
            /* 진한 핑크색 + 불투명하게 변경하여 가독성 확보 */
            background: rgba(255, 107, 169, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 25px rgba(255, 107, 169, 0.4);
        }

        /* 접힌 상태 (원형) */
        .fab-wrapper.collapsed {
            max-width: 60px;
            /* 버튼 하나 크기 */
            padding-left: 6px;
        }

        /* 숨김 상태 */
        .fab-wrapper.hidden {
            transform: translateY(100px);
            opacity: 0;
            pointer-events: none;
        }

        /* FAB 내부 버튼 공통 */
        .fab-child-btn {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .fab-child-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        .fab-child-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        /* SVG 아이콘 스타일 */
        .fab-icon-svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.2));
        }

        /* 구분선 */
        .fab-divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.4), transparent);
            flex-shrink: 0;

            /* 기본 상태 (보임) */
            margin: 0 4px;
            opacity: 1;
            transition: all 0.4s ease;
            /* 부드러운 전환 */
        }

        /* 추가 버튼 */
        #fab-add-btn {
            opacity: 1;
            width: 48px;
            /* 자신의 너비 */
            transform: scale(1);
            margin-left: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 접혔을 때: position: absolute를 쓰지 않고 크기를 0으로 줄임 */
        .fab-wrapper.collapsed .fab-divider {
            width: 0;
            margin: 0;
            /* 마진 제거 */
            opacity: 0;
        }

        .fab-wrapper.collapsed #fab-add-btn {
            width: 0;
            /* 너비 0 */
            margin: 0;
            opacity: 0;
            transform: scale(0);
            /* 작아지면서 사라짐 */
            pointer-events: none;
        }

        /* PC 화면 위치 조정 (유지) */
        @media (min-width: 768px) {
            .fab-wrapper {
                right: 50px !important;
            }
        }


        /* --- [CSS 수정] 검색 모달 (Liquid Glass) --- */

        /* 검색 모달 패널 자체를 투명한 유리처럼 */
        #modal-search .modal-panel {
            background: rgba(20, 20, 35, 0.65) !important;
            /* 다크모드 반투명 */
            backdrop-filter: blur(25px) !important;
            -webkit-backdrop-filter: blur(25px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
            border-radius: 24px 24px 0 0;
        }

        /* 라이트모드 검색 패널 */
        body.light-mode #modal-search .modal-panel {
            background: rgba(255, 255, 255, 0.95) !important;
            /* 거의 불투명한 흰색 */
            border: 1px solid rgba(255, 255, 255, 1);
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.1);
            /* 부드러운 그림자 */
        }

        /* 검색 헤더 */
        #modal-search .modal-sticky-header {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            /* 투명한 구분선 */
            padding: 15px 20px;
        }

        body.light-mode #modal-search .modal-sticky-header {
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* 2. 검색 입력창 (텍스트 겹침 해결) */
        #inp-search-query {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;

            /* [핵심 수정] 텍스트가 아이콘과 겹치지 않게 왼쪽 여백 확보 */
            padding: 12px 15px 12px 45px !important;

            font-size: 1.1rem;
            color: var(--text-main);
            width: 100%;
            transition: all 0.3s ease;

            /* 돋보기 아이콘 (다크모드용 연한색) */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23a8a8d8'%3E%3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 15px center;
            /* 아이콘 위치 조정 */
            background-size: 20px;
        }

        #inp-search-query:focus {
            background-color: rgba(0, 0, 0, 0.5);
            border-color: var(--primary);
            outline: none;
        }

        /* [라이트모드] 입력창 스타일 */
        body.light-mode #inp-search-query {
            background-color: rgba(120, 120, 128, 0.15) !important;
            /* iOS 스타일 연한 회색 */
            border-color: transparent;
            color: #333;

            /* 돋보기 아이콘 (라이트모드용 진한색) */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23888'%3E%3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E");
        }

        body.light-mode #inp-search-query::placeholder {
            color: #888;
        }

        body.light-mode #inp-search-query:focus {
            background-color: #fff !important;
            border-color: var(--primary);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        /* 필터 칩 (유리알 버튼) */
        .search-filter-bar {
            display: flex;
            gap: 10px;
            padding: 10px 0 20px 0;
            justify-content: center;
            /* 중앙 정렬 */
        }

        .filter-chip {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;

            /* 유리 질감 */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-dim);
            backdrop-filter: blur(5px);

            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .filter-chip:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .filter-chip.active {
            background: rgba(255, 143, 205, 0.2);
            /* 테마 컬러 틴트 */
            border-color: var(--primary);
            color: #fff;
            box-shadow: 0 4px 12px rgba(255, 143, 205, 0.3);
        }

        body.light-mode .filter-chip.active {
            background: rgba(255, 107, 169, 0.2);
            color: var(--accent);
            box-shadow: 0 4px 12px rgba(255, 107, 169, 0.3);
        }


        /* 검색 결과 리스트 (카드형) */
        #search-results-list {
            padding: 0 5px;
        }

        .search-result-item {
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 16px;

            /* 카드 유리 배경 */
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);

            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        body.light-mode .search-result-item {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        body.light-mode .search-result-item:hover {
            background: rgba(255, 255, 255, 0.9);
        }

        /* 위치 뱃지 */
        .location-badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(var(--primary-rgb), 0.15);
            /* 핑크 틴트 */
            color: var(--accent);
            font-weight: 600;
        }






        /* 4. 프로그레스 바 가독성 (배경 진하게) */
        .progress-btn {
            background: rgba(255, 255, 255, 0.05);
            /* 다크: 연한 투명 */
        }

        .progress-bg-bar {
            opacity: 0.8;
            /* 다크: 진하게 */
        }




        .tab-label {
            /* 기본적으로 숨겨서 축소 시 정렬 방해 금지 */
            display: none;
        }



        /* 라벨 등장 애니메이션 추가 */
        @keyframes fadeInLabel {
            0% {
                opacity: 0;
                transform: translateX(-10px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }



        .flag-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border-radius: var(--radius-m);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: 0.2s;
        }

        .flag-option:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary);
        }

        .flag-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .flag-name {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        /* 홈 대시보드 위젯 스타일 */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-widget {
            background: var(--stat-widget);
            border-radius: var(--radius-m);
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .stat-label1 {
            font-size: 0.8rem;
            color: var(--accent);
        }

        /* --- Utility Classes --- */
        .hidden {
            display: none !important;
        }

        .danger-text {
            color: var(--danger);
            font-size: 0.8rem;
            margin-top: 5px;
        }

        /* =========================================
   [모바일 최적화 수정] 480px 이하 화면 대응
   ========================================= */
        @media (max-width: 480px) {

            .header-card-inner {
                padding: 12px 10px !important;
                /* 기존 20px에서 줄임 */
            }

            /* --- 1. 헤더 툴바 레이아웃 --- */
            .glass-toolbar {
                padding: 4px 6px !important;
                /* 툴바 패딩 축소 */
                gap: 4px !important;
                height: auto !important;
                min-height: 32px !important;
                /* 툴바 최소 높이 더 축소 */
                display: flex;
                align-items: center;
                flex-wrap: nowrap !important;
            }

            /* 필터 그룹 (별표 + 텍스트 버튼들) 간격 조절 */
            .filter-group {
                gap: 3px !important;
                flex: 1 1 auto;
                width: auto;
                display: flex;
                align-items: center;
            }

            /* [핵심] 모든 필터/관리 버튼 공통 축소 */
            .icon-btn,
            .quiz-start-btn {
                width: 20px !important;
                height: 20px !important;
                min-width: 20px !important;
                /* 줄어들지 않는 현상 방지 */
                min-height: 20px !important;
                font-size: 0.6rem !important;
                margin: 0 !important;
                padding: 0 !important;
                display: flex !important;
                align-items: center;
                justify-content: center;
            }

            /* [수정 1 해결] 즐겨찾기(별) 버튼: 텍스트 버튼과 달리 '정원형' 강제 */
            .filter-icon-btn.btn-fav {
                width: 32px !important;
                min-width: 32px !important;
                height: 32px !important;
                /* 높이와 같은 너비 */
                flex: 0 0 32px !important;
                /* 절대 줄어들거나 늘어나지 않음 (고정) */
                padding: 0 !important;
                /* 내부 패딩 제거 */
                font-size: 1rem !important;
                /* 별 아이콘 크기는 적당히 유지 */
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50% !important;
                /* 완전한 원형 */
            }

            /* 관리 버튼 (우측 끝) */
            .manage-btn {
                flex: 0 0 auto;
                margin-left: auto !important;
                /* 오른쪽 끝으로 밀기 */
                width: auto !important;
                /* 내용물만큼만 차지 */
                min-width: 0 !important;
            }

            .filter-icon-btn,
            .manage-btn {
                padding: 8px 7px !important;
                font-size: 0.7rem !important;
                /* ★ 핵심 수정: 좌우 패딩을 8px -> 4px로 절반 축소 */
            }




            /* --- 2. 단어 리스트 아이템 (카드) 최적화 --- */
            .word-item {
                /* 카드 좌우 패딩을 줄여 공간 확보 */
                padding: 12px 10px !important;
                gap: 0 !important;
                /* flex gap 대신 개별 마진으로 제어 */
            }

            /* [좌측] 즐겨찾기/순번 영역 */
            .item-left-col {
                /* 기존 width 강제 해제 후 마진으로 제어 */
                width: auto !important;
                min-width: auto !important;
                flex: 0 0 auto !important;

                /* 요청하신대로 카드 끝과 단어 사이 여백 조정 */
                margin-left: 0 !important;
                /* 카드 왼쪽 끝과의 간격 (padding이 있으므로 0) */
                margin-right: 10px !important;
                /* 단어 텍스트와의 간격 10px 고정 */

                display: flex;
                justify-content: center;
                align-items: center;
            }

            .star-icon-img {
                width: 30%;
                height: 30%;
            }

            /* 별 아이콘/숫자 래퍼 크기 축소 */
            .star-index-wrapper {
                width: 26px !important;
                height: 26px !important;
            }

            .star-number {
                font-size: 0.6rem !important;
                /* 숫자 폰트 줄임 */
            }

            /* [중앙] 단어 텍스트 영역 */
            .word-content {
                /* 남은 공간 모두 차지 */
                flex: 1 1 auto;
                min-width: 0;
                /* 텍스트 말줄임(...)이 작동하려면 필수 */
                margin-right: 5px !important;
                /* 우측 버튼들과의 최소 간격 */
            }

            /* 단어 (메인 텍스트) */
            .word-row-main {
                font-size: 1rem !important;
                /* 폰트 사이즈 축소 (1.15 -> 1.0) */
                flex-wrap: wrap;
                /* 발음이 길면 줄바꿈 허용 */
            }

            /* 발음 기호 */
            .word-pron {
                font-size: 0.8rem !important;
            }

            /* 뜻 (서브 텍스트) */
            .word-row-sub {
                font-size: 0.9rem !important;
                margin-top: 2px !important;
            }


            /* [우측] 버튼 영역 (사전, 퀴즈) */
            .icon-actions {
                flex: 0 0 auto;
                /* 크기 고정 */
                gap: 5px !important;
                /* 버튼 사이 간격 좁힘 */
            }

            /* 원형 버튼들 (스피커, 퀴즈시작) 크기 축소 */
            .icon-btn,
            .quiz-start-btn {
                width: 28px !important;
                height: 28px !important;
                font-size: 0.75rem !important;
                padding-left: 5px !important;
                margin: 0 !important;
                /* 아이콘 크기 조절 */
            }

            .quiz-start-btn {

                padding: 0 !important;
                padding-left: 2px !important;
                /* 화살표 시각적 중앙 보정 (살짝 오른쪽으로) */

                display: inline-flex !important;
                align-items: center;
                justify-content: center;
            }

            /* 사전 버튼 (네이버) */
            .dict-btn {
                padding: 4px 10px !important;
                font-size: 0.75rem !important;
                height: 24px !important;
                /* 높이 명시 */
                line-height: 14px !important;
                /* 텍스트 수직 정렬 */
            }
        }

        /* 3. Drag Handle Style */
        .drag-handle {
            cursor: grab;
            font-size: 1.5rem;
            color: var(--text-dim);
            padding: 10px 15px;
            /* 터치 영역 확보 */
            touch-action: none;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .drag-handle:active {
            cursor: grabbing;
            color: var(--primary);
        }

        /* 드래그 중인 아이템 효과 */
        .word-item.dragging,
        .glass-card.dragging {
            opacity: 0.5;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed var(--accent);
        }

        /* 4. 그룹 리스트 관리 스타일 */
        .group-actions {
            display: none;
            align-items: center;
            gap: 8px;
        }

        /* 관리 모드가 아니어도 기본 버튼들이 예쁘게 보이게 */
        .btn-icon-text {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
            border-radius: 5px;
            color: var(--text-dim);
            transition: 0.2s;
        }

        .btn-icon-text:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-main);
        }

        .btn-icon-text.del:hover {
            color: var(--danger);
            background: rgba(255, 85, 119, 0.1);
        }


        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        /* 퀴즈 정답 버튼 스타일 */
        .choice-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            padding: 15px;
            border-radius: 15px;
            font-size: 1rem;
            color: var(--text-main);
            cursor: pointer;
            transition: 0.2s;
            text-align: left;
        }

        .choice-btn:active {
            background: var(--primary);
            color: white;
            border-color: transparent;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        /* 퀴즈 정답 버튼 스타일 */
        .choice-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            padding: 15px;
            border-radius: 15px;
            font-size: 1rem;
            color: var(--text-main);
            cursor: pointer;
            transition: 0.2s;
            text-align: left;
        }

        .choice-btn:active {
            background: var(--primary);
            color: white;
            border-color: transparent;
        }



        .quiz-start-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(255, 107, 169, 0.3);
            transition: transform 0.2s;
            margin-left: 8px;
            /* 사전 버튼 옆 간격 */
            padding-left: 7px;
            /* 시각적 중앙 보정 */
        }

        .quiz-start-btn:hover {
            transform: scale(1.1);
        }



        /* 타이틀 컨테이너 (스크롤 시 헤더 탑으로 이동 연출을 위해 분리) */
        .title-container {
            transition: 0.3s;
        }



        /* 뒤로가기 버튼 스타일 미세 조정 */
        .back-icon-btn {
            background: rgba(128, 128, 128, 0.1);
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: 0.2s;
            flex-shrink: 0;
        }

        .back-icon-btn:hover {
            background: var(--primary);
            color: #fff;
            border-color: transparent;
        }



        /* 타이틀 옆 편집 버튼 (작고 투명하게) */
        .title-edit-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            transition: 0.2s;
            opacity: 0.5;
            vertical-align: middle;
            display: inline-flex;
        }

        .title-edit-btn:hover {
            background: rgba(128, 128, 128, 0.2);
            opacity: 1;
            color: var(--primary);
        }

        /* Play All 버튼 */
        .play-all-btn {
            background: linear-gradient(135deg, var(--accent), var(--primary));
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: 0.3s;
            white-space: nowrap;
            flex-shrink: 0;
            /* 절대 안 줄어듦 */
        }

        .play-all-btn:hover {
            transform: translateY(-2px);
        }


        /* 2. 리스트 컨트롤 바 */
        .list-toolbar {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 15px 10px;
            gap: 10px;
        }

        .manage-btn {
            font-size: 0.85rem;
            padding: 6px 14px;
            background: var(--accent);
            color: #fff;
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 4px 6px rgba(86, 25, 47, 0.2);
        }

        .manage-btn.active {
            background: transparent;
            border: 2px solid var(--glass-border);
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 4px 10px rgba(86, 25, 47, 0.3);
            font-weight: 900;
        }

        /* 3. 리스트 아이템 리디자인 */
        .word-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 10px;
            background: var(--glass-bg);
            border: 1px solid transparent;
            border-bottom: 1px solid var(--glass-border);
            transition: 0.2s;
        }

        .word-item:first-child {
            border-radius: 16px 16px 0 0;
        }

        .word-item>div:first-child {
            flex: 0 0 32px !important;
            width: 32px !important;
            max-width: 32px !important;
            margin-right: 5px !important;
        }

        .word-item:last-child {
            border-bottom: none;
            border-radius: 0 0 16px 16px;
        }

        .word-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .item-number {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--text-dim);
            opacity: 0.5;
            width: 100%;
            /* 박스 안에서 꽉 차게 변경 */
            text-align: center;
        }

        .word-content {
            flex: 1;
            min-width: 0;
            /* Flexbox text-overflow issue fix */
            margin-right: 10px;
        }

        .word-row-main {
            font-size: 1.15rem;
            font-weight: bold;
            display: flex;
            align-items: baseline;
            gap: 8px;
            flex-wrap: wrap;
            /* 중요: Wrap 허용 */
        }

        .word-pron {
            font-size: 0.85rem;
            color: var(--accent);
            font-weight: normal;
        }

        .word-row-sub {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* 긴 뜻은 ... 처리 */
        }

        .word-item>div:first-child {
            width: 40px !important;
            height: 40px !important;
            margin-right: 5px !important;
            /* 간격 살짝 조정 */
            display: flex;
            justify-content: center;
            /* 가운데 정렬 */
            align-items: center;
        }

        /* 아이콘 액션 버튼들 */
        .icon-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-dim);
            cursor: pointer;
            transition: 0.2s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--primary);
            border-color: var(--primary);
        }

        .icon-btn.play-sound {
            color: var(--text-main);
        }

        /* 관리 모드일 때만 보이는 버튼 */
        .manage-controls {
            display: none;
            gap: 5px;
        }

        .word-item.managing .manage-controls {
            display: flex;
        }

        .word-item.managing .default-actions {
            display: none;
        }

        /* 순서 이동 버튼 */
        .move-btn {
            cursor: grab;
            font-size: 1.2rem;
            color: var(--text-dim);
            padding: 0 5px;
        }

        .move-btn:hover {
            color: var(--text-main);
        }

        .header-main-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }





        body.light-mode .glass-header.shrink {
            background: rgba(255, 255, 255, 0.98);
            /* 라이트모드 하얗게 */
        }




        /* 편집 버튼 */
        .title-edit-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-dim);
            font-size: 0.9rem;
            vertical-align: middle;
            opacity: 0.5;
            transition: 0.2s;
        }

        .title-edit-btn:hover {
            opacity: 1;
            color: var(--primary);
        }



        .fixed-header-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            background: transparent !important;
            /* <<-- 핵심: 투명화 */
            box-shadow: none !important;
            backdrop-filter: none !important;
            border: none !important;
            padding: 10px 0;
            /* 카드 위아래 여백 */
        }


        .header-card-inner {
            background: var(--header-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            /* 리스트와 폭 맞춤 (모바일 기준) */
            width: calc(100% - 40px);
            margin: 0 auto;
            /* 중앙 정렬 */
        }

        .delete-btn-x {
            background: rgba(255, 85, 119, 0.1);
            color: var(--danger);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            transition: 0.2s;
        }

        .delete-btn-x:hover {
            background: var(--danger);
            color: white;
        }


        .fixed-header-layer.shrunk {
            border-radius: 0;
            background: rgba(30, 30, 45, 0.98);
        }

        body.light-mode .fixed-header-layer.shrunk {
            background: rgba(255, 255, 255, 0.98);
        }

        .header-content {
            padding: 15px 20px 0 20px;
        }

        /* 2. 헤더 내부: 버튼 및 타이틀 줄 */
        .top-row {
            display: grid;
            /* 좌측버튼 | 빈공간 | 우측버튼 (타이틀은 모바일에서 아래로) */
            grid-template-columns: 40px 1fr auto;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        /* 축소 시 마진 줄임 */
        .fixed-header-layer.shrunk .top-row {
            margin-bottom: 5px;
        }

        /* 3. 통계 패널 (높이 애니메이션 대상) */
        .stats-wrapper {
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            opacity: 1;
            max-height: 400px;
            /* 헤더 하단 여백 */
        }

        .fixed-header-layer.shrunk .stats-wrapper {
            max-height: 0;
            margin-bottom: 0;
            opacity: 0;
        }

        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background: var(--card-bg);
            border: 1px solid var(--glass-border);
            text-align: center;
            border-radius: 12px;
            padding: 12px;
        }

        /* 4. 스크롤 영역 (실제 컨텐츠) */
        .scroll-content-area {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* 헤더 높이만큼 밀어주는 투명 Spacer */
        #header-spacer {
            transition: height 0.3s;
            pointer-events: none;
        }

        /* --- [모바일 타이틀 대응] --- */
        /* 기본(PC): 타이틀이 가운데 있음 */
        .header-title-area {
            grid-column: 2 / 3;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
            text-align: left;
        }

        .main-title {
            font-size: 1.6rem;
            margin: 0;
            font-weight: 800;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 600px 이하 모바일 */
        @media(max-width: 600px) {
            .top-row {
                /* 모바일은 2줄로: 버튼들(1줄) / 타이틀(2줄) */
                grid-template-columns: 40px 1fr auto;
                /* 타이틀을 위해 Grid Area 재정의하거나, 단순하게 타이틀 div를 밖으로 빼는게 나음. 
                   여기서는 CSS Grid Area로 재배치 */
                grid-template-areas:
                    "back . play"
                    "title title title";
                margin-bottom: 10px;
                gap: 5px;
            }

            .back-icon-btn {
                grid-area: back;
            }

            .play-all-btn {
                grid-area: play;
                justify-self: end;
            }

            .header-title-area {
                grid-area: title;
                margin-top: 5px;
            }

            /* 줄바꿈 허용 */
            .main-title {
                white-space: normal;
                word-break: keep-all;
                font-size: 1.4rem;
            }

            .header-subtitle {
                font-size: 0.8rem;
                margin-bottom: 2px;
            }

            /* 통계 그리드 2열 */
            .stats-dashboard {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }

            .stat-divider {
                display: none;
            }
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Shrunk 상태일때는 다시 한 줄로 (모바일도) */
        @media(max-width: 600px) {
            .fixed-header-layer.shrunk .top-row {
                grid-template-areas: "back title play";
                margin-bottom: 5px;
                gap: 10px;
            }

            .fixed-header-layer.shrunk .header-title-area {
                margin-top: 0;
            }

            .fixed-header-layer.shrunk .main-title {
                white-space: nowrap;
                font-size: 1.1rem;
                /* 다시 한 줄 말줄임 */
            }

            .fixed-header-layer.shrunk .header-subtitle {
                display: none;
            }
        }




        body.light-mode .glass-header.shrink {
            background: rgba(255, 255, 255, 0.98);
        }




        /* --- [UPDATED] Responsive Grid & Progress Button UI --- */

        /* 1. 홈 화면 반응형 그리드 (가로폭 씹힘 방지) */
        .lang-stat-grid {
            display: grid;
            /* 중요: minmax(0, 1fr)로 설정해야 컨테이너를 넘치지 않고 줄어듭니다. */
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important;
            grid-template-rows: auto auto;
            gap: 8px;
            margin-top: 15px;
            width: 100%;
            /* 부모에 꽉 차게 */
            box-sizing: border-box;
            /* 패딩 포함 */
        }

        /* 폰트 크기 반응형 자동 조절 (작은 화면에서 줄어들게) */
        .lang-stat-value {
            font-size: clamp(0.7rem, 4vw, 1.1rem);
            /* 최소 0.8, 최대 1.1 */
            font-weight: 700;
            white-space: nowrap;
        }

        /* 2. [NEW] Progress Button UI (버튼 위에 텍스트 + 진행률 배경) */
        .progress-btn-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        .progress-btn {
            position: relative;
            width: 100%;
            height: 60px;
            /* 높이 고정 (터치하기 좋게) */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            /* 기본 배경 (회색/투명) */
            border-radius: 30px;
            /* 둥근 캡슐 형태 */
            overflow: hidden;
            /* 배경 바가 튀어나가지 않게 */
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: transform 0.2s;
            user-select: none;
        }

        .progress-btn:active {
            transform: scale(0.98);
        }

        /* 실제 진행률을 나타내는 배경 바 (absolute로 뒤에 깔림) */
        .progress-bg-bar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            background: var(--primary);
            /* 진행 색상 */
            opacity: 0.8;
            transition: width 1s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 1;
        }

        /* 텍스트 내용 (z-index로 앞으로 뺌) */
        .progress-content {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            color: var(--text-main);
            /* 텍스트 색상 */
            font-weight: 600;
        }

        /* 정답률 텍스트 스타일 */
        .progress-rate {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        body.light-mode .progress-btn {
            background: rgba(255, 255, 255, 0.8);
            /* 라이트: 거의 흰색 */
            box-shadow: 0 2px 8px rgba(200, 150, 170, 0.1);
            /* 그림자 추가 */
            border: 1px solid rgba(200, 0, 100, 0.05);
        }

        body.light-mode .progress-bg-bar {
            opacity: 0.2;
            /* 라이트: 은은하게 */
        }

        /* 정답률 텍스트 잘 보이게 */
        body.light-mode .progress-content {
            color: #333;
            font-weight: 700;
        }

        body.light-mode .progress-rate {
            color: var(--accent);
        }

        /* 태그 리스트 배경 바 색상 (회색 대신 테마 컬러) */
        .progress-bg-bar[style*="background:var(--accent)"] {
            background: var(--accent) !important;
        }

        /* [추가] 모달 제목 정렬 */
        .modal-panel h3 {
            margin: 10px 0;
            text-align: center;
        }





        /* 3. 모달 스크롤 레이아웃 재정의 */
        /* 전체 화면 덮는 모달 (기존 클래스 덮어쓰기) */
        .modal-panel.scrollable-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            max-width: 100% !important;
            /* PC 제한 해제 */
            border-radius: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-main);
            /* 배경색 불투명하게 */
        }



        body.light-mode .modal-sticky-header {
            /* 라이트모드 헤더 */
            background: rgba(253, 238, 245, 0.98);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        body.light-mode .modal-sticky-header {
            background: rgba(255, 255, 255, 0.85);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }


        /* 기존 단순 컨텐츠 래퍼 (.modal-panel 바로 아래 div 등) 호환성 처리 */
        .modal-panel>h3,
        .modal-panel>p.desc,
        .modal-panel>div.input-group,
        .modal-panel>div.flag-grid {
            /* 만약 .modal-scroll-body 안에 없더라도 최소한의 마진 확보 */
            margin-left: 20px;
            margin-right: 20px;
        }

        /* 플래그 그리드 마진 복구 */
        .flag-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* 한 줄에 3개 */
            gap: 15px;
            /* 카드 사이 간격 */
            row-gap: 25px;
            /* 줄 사이 간격 (버튼끼리 너무 붙지 않게) */
            margin-top: 25px;
            padding: 10px;
            /* 그리드 자체 패딩 */
        }

        /* 2. 설정창 등 모달 내부 카드 간격 */
        .modal-card-spacer {
            margin-bottom: 20px;
            /* 카드들 사이의 여백 */
        }


        /* 5. 퀴즈 기록 리스트 아이템 스타일 (리스트형) */
        .history-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
        }

        .history-item:active {
            background: rgba(255, 255, 255, 0.08);
            transform: scale(0.98);
        }

        body.light-mode .history-item {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.03);
        }

        /* 그라디언트 텍스트 (리퀴드 포인트) */
        .liquid-text-gradient {
            background: linear-gradient(135deg, var(--text-main) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }

        /* 강조용 태그 스타일 */
        .group-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            background: rgba(var(--primary-rgb), 0.1);
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 4px;
        }






        /* 2. 고도화된 차트 및 하단 상세 뷰 스타일 */

        /* 차트 컨테이너 */
        .chart-wrapper {
            background: rgba(0, 0, 0, 0.2);
            /* 차트 배경을 조금 더 어둡게 */
            border-radius: 20px;
            padding: 20px 10px 5px 10px;
            /* 상우하좌 */
            margin: 20px 0;
            border: 1px solid var(--glass-border);
            position: relative;
        }

        body.light-mode .chart-wrapper {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.02);
        }

        /* 차트 요소들 */
        .chart-axis-line {
            stroke: var(--text-dim);
            stroke-width: 0.5;
            opacity: 0.3;
        }

        .chart-axis-text {
            fill: var(--text-dim);
            font-size: 10px;
        }

        .chart-line-path {
            fill: none;
            stroke: var(--primary);
            stroke-width: 3;
            stroke-linecap: round;
        }

        .chart-dot {
            fill: var(--bg-main);
            stroke: var(--primary);
            stroke-width: 1px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .chart-dot:hover,
        .chart-dot.selected {
            r: 6;
            stroke: white;
            fill: var(--accent);
        }

        /* 3. 하단 상세 정보 카드 (애니메이션 포함) */
        .detail-view-container {
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .detail-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* 오답 리스트 아이템 스타일 */
        .wrong-item-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.light-mode .wrong-item-row {
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .wrong-item-row:last-child {
            border-bottom: none;
        }

        @media (max-width: 600px) {
            .lang-stat-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            /* 모바일 2열 */
        }

        /* 태그 프로그레스 바 */
        .tag-stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 12px;
        }

        .tag-name {
            width: 80px;
            font-weight: bold;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .progress-track {
            flex: 1;
            height: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            margin: 0 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.5s ease;
        }

        .tag-pct {
            width: 45px;
            text-align: right;
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent);
        }

        /* SVG 차트 스타일 */
        .chart-container {
            width: 100%;
            height: 250px;
            position: relative;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 15px;
            padding: 10px;
            border: 1px solid var(--glass-border);
        }

        .chart-point {
            cursor: pointer;
            transition: r 0.2s;
        }

        .chart-point:hover {
            r: 6;
            fill: white;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
        }





        /* --- [FINAL FIX] Modal Engine & Layout --- */

        /* 1. 오버레이: 전체 화면을 덮고, 자식(패널)을 아래쪽에 정렬 */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            /* 배경 더 어둡게 (뒤 화면 가림) */
            backdrop-filter: blur(8px);
            /* 블러 강화 */
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;

            /* Flexbox로 패널 위치 잡기 */
            flex-direction: column;
            justify-content: flex-end;
            /* 아래쪽 정렬 */
            align-items: center;
            /* 가로 중앙 */
        }

        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        /* 2. 패널: 오버레이 안에서 아래쪽에서 올라옴 */
        .modal-panel,
        .modal-panel.scrollable-modal {
            position: relative;
            /* Fixed가 아닌 Relative로 변경 (중요) */
            width: 100%;
            max-width: 600px;
            /* PC에서는 너무 안 퍼지게 */
            height: 92vh;
            /* 높이 설정 */

            background: rgba(30, 30, 45, 0.98);
            /* 거의 불투명하게 (뒤 안 비치게) */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
            border-radius: 28px 28px 0 0;

            box-shadow: 0 -10px 50px rgba(0, 0, 0, 0.7);

            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.2, 0.8, 0.2, 1);

            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-overlay.active .modal-panel {
            transform: translateY(0);
        }

        /* [라이트모드 패널] */
        body.light-mode .modal-panel,
        body.light-mode .modal-panel.scrollable-modal {
            background: #ffffff;
            /* 완전 흰색 배경 (가독성 최우선) */
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* 3. 모달 헤더 */
        .modal-sticky-header {
            flex-shrink: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            background: inherit;
            /* 패널 배경색 따라감 */
        }

        body.light-mode .modal-sticky-header {
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* 4. 스크롤 본문 (여백 재설정) */
        .modal-scroll-body {
            flex: 1;
            overflow-y: auto;
            /* 좌우 여백 20px, 하단 여백을 넉넉하게 50px로 늘려 사진 속 '마진 추가' 요청 해결 */
            padding: 20px 20px 50px 20px;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            /* 너비 꽉 채우기 */
            box-sizing: border-box;
            /* 패딩 포함 너비 계산 */
        }

        /* [추가] 모달 내부에서 버튼들이 바닥에 붙지 않게 감싸는 컨테이너 */
        .modal-footer-gap {
            height: 30px;
            width: 100%;
        }

        /* 입력 필드 그룹 마진 수정 */
        .input-group {
            margin-bottom: 15px;
            width: 100%;
        }

        select option {
            background-color: var(--bg-main);
            /* 테마 배경색 따름 */
            color: var(--text-main);
            /* 테마 글자색 따름 */
        }

        /* --- <style> 맨 아래에 추가 --- */

        /* 로고 이미지 스타일 */
        .logo-container {
            display: flex;
            justify-content: center;
            /* 가운데 정렬 */
            align-items: center;
            width: 100%;
            margin-bottom: 20px;
            padding-top: 10px;
        }

        .app-logo {
            height: 270px;
            /* 상단 로고 기본 높이 */
            width: auto;
            object-fit: contain;
            transition: all 0.3s ease;
        }

        /* 설정창 하단 앱 정보 카드용 큰 로고 */
        .app-logo.large {
            height: 270px;
            margin-bottom: 10px;
        }

        /* --- [CSS 수정] 1. 홈 대시보드 그리드 개선 (모바일 잘림 방지) --- */
        /* 기존 .lang-stat-grid 관련 스타일이 있다면 덮어씌워짐, 혹은 별도 클래스로 활용 */
        .dashboard-responsive-grid {
            display: grid;
            /* 핵심: 화면이 좁을 땐 100%를 채우고, 여유가 생기면 최소 260px씩 나눔 */
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 260px), 1fr));
            gap: 20px;
            padding-bottom: 100px;
            width: 100%;
            box-sizing: border-box;
            /* 패딩 포함 너비 계산 */
        }

        /* --- [CSS 수정] 2. 모달 애니메이션 로직 개선 --- */
        .modal-overlay {
            display: none;
            /* JS로 active 클래스가 붙으면 flex로 변경됨 */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 2000;

            /* 투명도 애니메이션 */
            opacity: 0;
            transition: opacity 0.3s ease;

            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        /* 활성화 상태 (열림) */
        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        /* 닫히는 중 상태 (JS에서 닫기 버튼 누르면 잠시 이 클래스를 부여) */
        .modal-overlay.closing {
            display: flex;
            /* 닫히는 동안에도 보여야 함 */
            opacity: 0;
            /* 투명해짐 */
        }

        .modal-panel {
            /* 기존 스타일 유지하되 transform 초기값 설정 */
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 92vh;
            background: rgba(30, 30, 45, 0.98);
            /* 다크모드 기본 */
            border-radius: 28px 28px 0 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;

            /* 아래에서 올라오는 애니메이션 */
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        /* 라이트모드 대응 */
        body.light-mode .modal-panel {
            background: #ffffff;
            border-color: rgba(0, 0, 0, 0.1);
        }

        /* 모달이 활성화되면 패널이 올라옴 */
        .modal-overlay.active .modal-panel {
            transform: translateY(0);
        }

        /* 닫히는 중에는 패널이 다시 내려감 */
        .modal-overlay.closing .modal-panel {
            transform: translateY(100%);
        }


        /* --- [CSS 추가] 초기 설정 마법사 스타일 --- */
        .setup-step.hidden {
            display: none;
        }

        /* 선택된 테마 버튼 강조 */
        .theme-selected {
            border-color: var(--primary) !important;
            background: rgba(var(--primary-rgb), 0.1) !important;
            font-weight: bold;
            color: var(--primary) !important;
        }

        /* [CSS 추가] 데스크톱(PC) 화면에서 FAB 위치 조정 */
        /* 화면 너비가 768px 이상일 때 적용됩니다 */
        @media (min-width: 768px) {
            .fab-wrapper {
                right: 50px !important;
                /* 기존 20px + 30px = 50px */
            }
        }

        html,
        body {
            touch-action: pan-x pan-y;
            /* 스크롤은 허용하되, 확대/축소 제스처(pinch) 차단 */
            overscroll-behavior: none;
            /* 맥락없는 바운스 방지 */
        }

        /* [수정 1] 필터 버튼 그룹 */
        .filter-group {
            display: flex;
            gap: 8px;
        }

        .filter-icon-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            /* 둥글게 */
            padding: 6px 14px;
            /* 좌우 여백 확보 */
            cursor: pointer;
            font-size: 0.85rem;
            /* 텍스트 크기 */
            color: var(--text-dim);
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            /* 줄바꿈 방지 */
        }

        .filter-icon-btn.active {
            background: var(--primary);
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 8px rgba(255, 143, 205, 0.4);
        }

        /* [수정 2] 별표 안의 숫자 디자인 */
        .star-index-wrapper {
            position: relative;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-left: -5px;
        }

        .star-icon-img {
            width: 100%;
            /* 부모(50px) 대비 크기 조절 */
            height: 100%;
            object-fit: contain;
            transition: all 0.2s;
            /* 기본(활성) 상태: 원본 색상(노랑 가정) 유지 */
            filter: none;
        }

        .star-index-wrapper.active .star-svg {
            fill: #FFD700;
            /* 활성: 금색 */
            filter: drop-shadow(0 2px 3px rgba(203, 177, 152, 0.2));
        }

        /* 비활성 상태: 회색조로 변경하고 투명도 적용 */
        .star-index-wrapper:not(.active) .star-icon-img {
            filter: grayscale(100%) opacity(0.1);
        }

        /* 활성 상태: 그림자 효과 */
        .star-index-wrapper.active .star-icon-img {
            /* 검정색 -> 금색(#FFD700)으로 바꾸는 매직 필터 */
            filter: invert(86%) sepia(31%) saturate(5793%) hue-rotate(359deg) brightness(102%) contrast(106%) drop-shadow(0 2px 4px rgba(255, 215, 0, 0.5)) !important;

            transform: scale(1.1);
            /* 약간 커지는 효과 */
            opacity: 1;
        }

        .star-number {
            position: absolute;
            font-size: 0.65rem;
            font-weight: 900;
            color: var(--text-dim);
            z-index: 2;
            pointer-events: none;
            /* 클릭 통과 */
            line-height: 1;
        }

        .star-index-wrapper.active .star-number {
            color: #635300 !important;
            /* 진한 금색/갈색 텍스트 */
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .filter-icon-btn.btn-fav {
            border: 1px solid #FFD700 !important;
            color: #FFD700 !important;
            background: rgba(255, 239, 11, 0.1) !important;

            /* 너비/높이를 고정하여 원형 유지 */
            width: 40px;
            height: 40px;
            min-width: 40px;
            /* 모바일 flex 축소 방지 */

            border-radius: 50%;
            /* 완전한 원형 */
            padding: 0;
            /* 내부 여백 제거하여 아이콘 중앙 정렬 */

            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            /* 줄어들지 않음 */

            font-size: 1.2rem;
            /* 별 아이콘 크기 적절히 */
        }


        .filter-icon-btn.btn-fav.active {
            background: #FFD700 !important;
            color: #333 !important;
            /* 활성화 시 글자색 */
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }


        /* 헤더 내부 툴바 스타일 보완 */
        .glass-toolbar {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        /* 라이트 모드 대응 */
        body.light-mode .glass-toolbar {
            background: rgba(255, 255, 255, 0.6) !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }
    </style>


</head>

<body class="dark-mode">

    <!-- [수정] 초기 설정 팝업 (데이터 불러오기 추가 + 내부 로직 개선) -->
    <div id="setup-popup" class="modal-overlay">
        <div class="modal-panel">
            <!-- 상단 헤더 (단계 표시용, 1단계에선 숨김) -->
            <div class="modal-sticky-header" id="setup-header" style="display:none;">
                <button onclick="prevSetupStep()" class="back-icon-btn">←</button>
                <h3 style="margin:0; font-size:1.1rem;">초기 설정</h3>
                <div style="width:40px;"></div>
            </div>

            <div class="modal-scroll-body" style="padding-top:20px;">

                <!-- STEP 1: 환영 인사 & 데이터 복원 -->
                <div id="setup-step-1" class="setup-step">
                    <div
                        style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh;">
                        <div class="logo-container" style="margin-bottom:30px;">
                            <img src="./Asset/PrismV_dark.png" class="app-logo large" id="setup-logo" alt="PrismV Logo"
                                style="height:150px;">
                        </div>
                        <h1 style="font-size:2rem; margin:0 0 10px 0;" class="liquid-text-gradient">Welcome!</h1>
                        <p class="desc">당신의 단어를 기록하고, 완벽하게 기억하세요.</p>

                        <!-- [추가됨] 숨겨진 파일 입력 -->
                        <input type="file" id="setup-file-import" style="display:none;"
                            onchange="importSetupData(this)">

                        <!-- 시작하기 버튼 -->
                        <button class="glass-btn primary" onclick="goSetupStep(2)"
                            style="margin-top:40px; width:80%;">시작하기</button>

                        <!-- [추가됨] 기존 정보 불러오기 버튼 (태두리만) -->
                        <button class="glass-btn" onclick="triggerSetupImport()"
                            style="margin-top:10px; width:80%; background:transparent; border:1px solid var(--text-dim); color:var(--text-dim);">
                            📂 기존 정보 불러오기
                        </button>
                    </div>
                </div>

                <!-- STEP 2: 언어 설정 -->
                <div id="setup-step-2" class="setup-step hidden">
                    <div style="text-align:center; margin-bottom:20px;">
                        <h2 style="margin:0;">언어 설정 🌐</h2>
                        <p class="desc">모국어와 학습할 언어를 선택하세요.</p>
                    </div>

                    <!-- 모국어 선택 -->
                    <div class="glass-card" style="padding:20px; margin-bottom:20px;">
                        <label class="input-label" style="margin-bottom:8px;">나의 모국어 (System Language)</label>
                        <select id="setup-sys-lang" onchange="updateSysLang(this.value)" style="margin:0;">
                            <option value="ko">한국어 (Korean)</option>
                            <option value="en">English</option>
                            <option value="ja">日本語</option>
                            <option value="zh">中文 (Chinese)</option>
                            <option value="es">Español (Spanish)</option>
                        </select>
                    </div>

                    <!-- 학습 언어 선택 (그리드) -->
                    <label class="input-label" style="margin-left:5px; margin-bottom:10px;">학습할 언어 추가</label>
                    <div id="setup-flag-grid" class="flag-grid" style="margin-top:0; padding:0;">
                        <!-- JS로 렌더링 -->
                    </div>

                    <div style="height:30px;"></div>
                    <button class="glass-btn primary" onclick="goSetupStep(3)">다음 (Next)</button>
                </div>

                <!-- STEP 3: 테마 및 미리보기 -->
                <div id="setup-step-3" class="setup-step hidden">
                    <div style="text-align:center; margin-bottom:20px;">
                        <h2 style="margin:0;">테마 설정 🎨</h2>
                        <p class="desc">눈이 편안한 모드를 선택하세요.</p>
                    </div>

                    <!-- 테마 버튼 -->
                    <div style="display:flex; gap:15px; margin-bottom:30px; justify-content:center;">
                        <button class="glass-btn" onclick="previewTheme('dark')" id="btn-setup-dark"
                            style="flex:1; border:2px solid var(--glass-border);">Dark 🌙</button>
                        <button class="glass-btn" onclick="previewTheme('light')" id="btn-setup-light"
                            style="flex:1; border:1px solid var(--glass-border);">Light ☀️</button>
                    </div>

                    <!-- 미리보기 카드 -->
                    <label class="input-label" style="text-align:center; margin-bottom:10px;">미리보기 (Preview)</label>
                    <div class="glass-card word-item"
                        style="padding:15px; display:flex; align-items:center; opacity:1; transform:scale(1);">
                        <div style="width:15px; text-align:center; color:var(--text-dim); font-size:0.9rem;">1</div>
                        <div style="flex:1; margin-left:10px;">
                            <div style="color:var(--text-main); font-weight:600; font-size:1.15rem;">
                                Prism <span
                                    style="font-weight:normal; color:var(--accent); font-size:0.85rem; margin-left:5px;">[prɪzəm]</span>
                            </div>
                            <div style="color:var(--text-dim); margin-top:2px; font-size:1rem;">프리즘, 분광</div>
                        </div>
                        <div class="icon-btn"
                            style="width:32px; height:32px; display:flex; align-items:center; justify-content:center;">
                            🔊</div>
                    </div>

                    <div style="height:50px;"></div>
                    <button class="glass-btn primary" onclick="finishSetup()">설정 완료 (Finish)</button>
                </div>

                <div class="modal-footer-gap"></div>
            </div>
        </div>
    </div>

    <div class="app-wrapper">
        <!-- 메인 네비게이션 (Tabs) -->
        <nav class="tab-bar" id="app-nav-bar">
            <!-- JS로 홈 + 언어탭 생성 -->
        </nav>

        <main class="container" id="main-view-area">
            <!-- JS가 현재 탭에 맞는 화면(홈 위젯 or 언어별 그룹)을 여기에 그립니다 -->
        </main>
    </div>

    <!-- [수정] 리퀴드 글래스 FAB (SVG 아이콘) -->
    <div class="fab-wrapper" id="main-fab-wrapper">
        <!-- 1. 검색 버튼 (SVG) -->
        <button class="fab-child-btn" onclick="openSearchModal()" aria-label="Search">
            <svg class="fab-icon-svg" viewBox="0 0 24 24">
                <path
                    d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
            </svg>
        </button>

        <!-- 2. 구분선 -->
        <div class="fab-divider"></div>

        <!-- 3. 추가 버튼 (SVG) -->
        <button class="fab-child-btn" id="fab-add-btn" aria-label="Add">
            <svg class="fab-icon-svg" viewBox="0 0 24 24" style="width:28px; height:28px;">
                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
            </svg>
        </button>
    </div>

    <!-- [신규] 단어 검색 모달 -->
    <div id="modal-search" class="modal-overlay">
        <div class="modal-panel">
            <div class="modal-sticky-header">
                <button onclick="closeModal('modal-search')" class="back-icon-btn"
                    style="border:none; background:none;">✕</button>
                <div style="flex:1; margin:0 10px;">
                    <!-- 검색 입력창 -->
                    <input type="text" id="inp-search-query" placeholder="Search..."
                        style="margin:0; border-radius:20px; padding:10px 15px; font-size:1rem;" oninput="runSearch()">
                </div>
            </div>

            <div class="modal-scroll-body" style="padding-top:10px;">
                <!-- 범주 필터 -->
                <div class="search-filter-bar">
                    <button class="filter-chip active" onclick="setSearchFilter('all')" id="filter-all">전체</button>
                    <button class="filter-chip" onclick="setSearchFilter('term')" id="filter-term">단어</button>
                    <button class="filter-chip" onclick="setSearchFilter('mean')" id="filter-mean">뜻</button>
                </div>

                <!-- 검색 결과 리스트 -->
                <div id="search-results-list">
                    <p class="desc" style="text-align:center; margin-top:50px;">단어를 검색해보세요.</p>
                </div>
                <div class="modal-footer-gap"></div>
            </div>
        </div>
    </div>

    <!-- [수정] Modal: 단어 추가/수정 (Label 정리 + 예문으로 변경) -->
    <div id="modal-add-word" class="modal-overlay">
        <div class="modal-panel">
            <!-- 고정 헤더 영역 -->
            <div class="modal-sticky-header">
                <button onclick="closeModal('modal-word-detail')" class="back-icon-btn"
                    style="border:none; background:none;">✕</button>
                <h3 style="margin:0; font-size:1.1rem;">${t('word_detail')}</h3>
                <button id="btn-detail-edit" class="title-edit-btn" style="font-size:1.1rem; opacity:1;">✎</button>
            </div>

            <!-- 스크롤 본문 영역 -->
            <div class="modal-scroll-body">
                <p class="desc" style="text-align:center; margin-bottom:20px;">현재 언어: <span id="current-lang-display"
                        style="color:var(--primary); font-weight:bold;">-</span></p>

                <style>
                    .input-group {
                        margin-bottom: 10px;
                    }

                    .input-label {
                        display: block;
                        font-size: 0.8rem;
                        color: var(--text-dim);
                        margin-bottom: 4px;
                        font-weight: 600;
                    }

                    .tag-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: 4px;
                        background: rgba(255, 255, 255, 0.05);
                        border: 1px solid var(--glass-border);
                        border-radius: 8px;
                        padding: 6px 12px;
                        margin: 0 6px 6px 0;
                        /* 간격 */
                        font-size: 0.85rem;
                        color: var(--text-dim);
                        cursor: pointer;
                        transition: 0.2s;
                        user-select: none;
                    }

                    .tag-chip:hover {
                        border-color: var(--primary);
                        color: var(--text-main);
                        background: rgba(255, 255, 255, 0.1);
                    }
                </style>

                <!-- 단어 입력 -->
                <div class="input-group">
                    <span class="input-label" id="lbl-term">단어/표현</span>
                    <input type="text" id="inp-term" placeholder="Prism">
                </div>

                <!-- 발음 입력 -->
                <div class="input-group">
                    <span class="input-label" id="lbl-pron">발음/읽는 법</span>
                    <input type="text" id="inp-pron" placeholder="[prɪzəm]">
                </div>

                <!-- 뜻 입력 -->
                <div class="input-group">
                    <span class="input-label" id="lbl-mean">뜻/의미</span>
                    <input type="text" id="inp-mean" placeholder="프리즘, 분광">
                </div>

                <!-- 예문(메모) 입력 -->
                <div class="input-group">
                    <span class="input-label" id="lbl-memo">예문 (선택)</span>
                    <input type="text" id="inp-memo" placeholder="A prism decomposes light into a spectrum.">
                </div>

                <!-- 태그 입력 및 범주 목록 -->
                <div class="input-group" style="position:relative;">
                    <span class="input-label" id="lbl-tags">태그 (선택)</span>
                    <input type="text" id="inp-tags" placeholder="#IT #Science" oninput="filterTags(this.value)">
                    <div id="tag-suggestions"
                        style="margin-top:8px; max-height:100px; overflow-y:auto; display:flex; flex-wrap:wrap;"></div>
                </div>

                <!-- 버튼 영역 -->
                <div style="display:flex; gap:10px; margin-top:25px;">
                    <button class="glass-btn primary" onclick="saveWord(false)" id="btn-save"
                        style="flex:1;">저장</button>
                    <button class="glass-btn primary" onclick="saveWord(true)" id="btn-save-cont"
                        style="flex:1; background:rgba(255,255,255,0.2); border:1px solid var(--accent);">저장 &
                        계속</button>
                </div>
                <button class="glass-btn" onclick="closeModal('modal-add-word')" id="btn-cancel"
                    style="margin-top:10px;">취소</button>
                <div style="height:30px;"></div>
            </div>
        </div>
    </div>

    <!-- [수정] Modal: 언어 추가 -->
    <!-- [수정] Modal: 언어 추가 (구조 통일) -->
    <div id="modal-add-lang" class="modal-overlay">
        <div class="modal-panel">
            <div class="modal-sticky-header">
                <button onclick="closeModal('modal-add-lang')" class="back-icon-btn"
                    style="border:none; background:none;">✕</button>
                <h3 style="margin:0; font-size:1.1rem;">언어 추가/관리</h3>
                <div style="width:40px;"></div>
            </div>
            <div class="modal-scroll-body">
                <p class="desc" style="text-align:center; margin-bottom:15px;">국기를 클릭하여 학습 언어를 추가하세요.</p>
                <div id="flag-selection-area" class="flag-grid" style="margin-bottom:20px;">
                    <!-- JS로 국기 버튼 생성됨 -->
                </div>
                <button class="glass-btn" onclick="closeModal('modal-add-lang')">닫기</button>
                <div class="modal-footer-gap"></div>
            </div>
        </div>
    </div>

    <!-- [수정] Modal: 새 단어장 (디자인 개선) -->
    <div id="modal-create-group" class="modal-overlay">
        <div class="modal-panel">
            <div class="modal-sticky-header">
                <button onclick="closeModal('modal-create-group')" class="back-icon-btn"
                    style="border:none; background:none;">✕</button>
                <h3 style="margin:0; font-size:1.1rem;">새 단어장 만들기</h3>
                <div style="width:40px;"></div>
            </div>

            <div class="modal-scroll-body">
                <!-- 안내 문구 -->
                <div style="text-align:center; margin: 10px 0 30px 0;">
                    <div style="font-size:3rem; margin-bottom:10px;">📁</div>
                    <p class="desc" style="margin:0;">새로운 단어장의 이름과 설명을 입력하세요.</p>
                </div>

                <!-- 입력 폼 -->
                <div class="glass-card" style="padding:20px; margin-bottom:20px;">
                    <div class="input-group">
                        <span class="input-label" style="margin-left:2px;">단어장 이름</span>
                        <input type="text" id="inp-group-title" style="margin-bottom:15px;">
                    </div>

                    <div class="input-group" style="margin-bottom:0;">
                        <span class="input-label" style="margin-left:2px;">설명 (선택)</span>
                        <input type="text" id="inp-group-desc" placeholder="예: 토익 필수 영단어 Day 1"
                            style="margin-bottom:0;">
                    </div>
                </div>

                <!-- 버튼 -->
                <div style="display:flex; gap:10px; margin-top:10px;">
                    <button class="glass-btn primary" onclick="submitCreateGroup()"
                        style="height:50px; font-size:1rem;">생성하기</button>
                    <button class="glass-btn" onclick="closeModal('modal-create-group')"
                        style="height:50px;">취소</button>
                </div>

                <div class="modal-footer-gap"></div>
            </div>
        </div>
    </div>

    <!-- [3단계 신규] 퀴즈 설정 모달 -->
    <div id="modal-quiz-setup" class="modal-overlay">
        <div class="modal-panel">
            <h3>퀴즈 설정 📝</h3>
            <div class="glass-card" style="margin-top:15px; padding:15px;">
                <!-- TTS 토글 -->
                <label style="display:flex; justify-content:space-between; align-items:center;">
                    <span>🔊 TTS(음성) 듣기</span>
                    <input type="checkbox" id="chk-tts" checked
                        style="width:20px; height:20px; accent-color:var(--primary);">
                </label>
                <hr style="border:0; border-top:1px solid var(--glass-border); margin:12px 0; opacity:0.3;">

                <!-- 문제 유형 체크박스들이 들어갈 자리 -->
                <span class="input-label" style="margin-bottom:8px;">출제 유형 선택</span>
                <div id="quiz-types-area" style="display:flex; flex-direction:column; gap:8px; margin-bottom:10px;">
                </div>
            </div>

            <!-- 옵션: 랜덤, 이어하기 -->
            <div class="glass-card"
                style="padding:15px; display:flex; justify-content:space-between; align-items:center;">
                <span>🔀 랜덤 순서 (이어하기 불가)</span>
                <input type="checkbox" id="chk-random" onchange="toggleContinueBtn()"
                    style="width:20px; height:20px; accent-color:var(--accent);">
            </div>

            <!-- 실행 버튼들 -->
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="glass-btn primary" onclick="launchQuiz('start')" style="flex:1;">처음부터 시작</button>
                <button class="glass-btn" id="btn-quiz-continue" onclick="launchQuiz('continue')" style="flex:1;">이어서
                    시작</button>
            </div>
            <button class="glass-btn" onclick="closeModal('modal-quiz-setup')" style="margin-top:10px;">취소</button>
        </div>
    </div>

    <!-- [3단계 신규] 퀴즈 플레이 화면 (전체화면 오버레이) -->
    <div id="quiz-screen"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:var(--bg-main); background-image:var(--bg-gradient-dark); z-index:2000; display:none; flex-direction:column; padding:20px;">
        <!-- 상단 헤더 -->
        <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <button onclick="exitQuiz()"
                style="background:none; border:none; color:var(--text-dim); font-size:1.5rem; cursor:pointer;">✕</button>
            <div style="flex:1; margin:0 20px;">
                <!-- 진행바 -->
                <div style="height:8px; background:rgba(255,255,255,0.1); border-radius:4px; overflow:hidden;">
                    <div id="quiz-progress-bar"
                        style="height:100%; width:0%; background:var(--primary); transition:width 0.3s ease;">
                    </div>
                </div>
            </div>
            <span id="quiz-progress-text" style="color:var(--text-dim); font-size:0.9rem;">0/0</span>
        </header>

        <!-- 메인 문제 영역 -->
        <main id="quiz-content"
            style="flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; position:relative;">
            <!-- 문제 타입 뱃지 -->
            <span id="q-type-badge"
                style="background:rgba(255,255,255,0.1); border:1px solid var(--glass-border); padding:4px 10px; border-radius:15px; font-size:0.8rem; margin-bottom:20px; color:var(--accent);">TYPE</span>

            <!-- TTS 버튼 -->
            <button id="q-tts-btn" onclick="speakCurrent()"
                style="background:none; border:2px solid var(--text-main); border-radius:50%; width:50px; height:50px; font-size:1.5rem; margin-bottom:15px; cursor:pointer; display:none;">🔊</button>

            <!-- 문제 텍스트 -->
            <h1 id="q-text" style="font-size:2.2rem; font-weight:700; margin:0 0 40px 0; word-break:keep-all;">
                Question
            </h1>

            <!-- 정답 입력/선택 영역 -->
            <div id="q-answer-area" style="width:100%; max-width:400px; display:flex; flex-direction:column; gap:10px;">
            </div>

            <!-- 정오답 피드백 오버레이 -->
            <div id="q-feedback"
                style="position:absolute; bottom:0; left:0; width:100%; background:rgba(20,20,30,0.95); backdrop-filter:blur(10px); padding:20px; border-radius:40px 40px 40px 40px; border-top:1px solid var(--glass-border); display:none; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);">
                <h2 id="fb-title" style="margin:0 0 10px 0; font-size:1.5rem;">Result</h2>
                <div id="fb-detail" style="font-size:1rem; line-height:1.5; color:var(--text-dim); margin-bottom:20px;">
                    Detail</div>
                <button class="glass-btn primary" onclick="nextQuestion()" id="fb-next-btn">다음 (Next) ▶</button>
            </div>
        </main>
    </div>

    <!-- [신규] 단어 상세 보기 모달 -->
    <div id="modal-word-detail" class="modal-overlay">
        <div class="modal-panel">
            <div class="modal-sticky-header">
                <button onclick="closeModal('modal-word-detail')" class="back-icon-btn"
                    style="border:none; background:none;">✕</button>
                <h3 style="margin:0; font-size:1.1rem;">${t('word_detail')}</h3>
                <button id="btn-detail-edit" class="title-edit-btn" style="font-size:1.1rem; opacity:1;">✎</button>
            </div>

            <div class="modal-scroll-body">
                <div style="text-align:center; margin-bottom:20px;">
                    <h1 style="margin:0; font-size:2.2rem; word-break:break-all;">${word.term}</h1>
                    <div style="font-size:1.1rem; color:var(--accent); margin-top:5px;">${word.pron ? `[${word.pron}]` :
                        ''}</div>
                </div>

                <div class="glass-card" style="margin-bottom:15px; padding:15px;">
                    <span class="input-label">${t('mean')}</span>
                    <div style="font-size:1.2rem; font-weight:600; color:var(--text-main);">${word.mean}</div>
                </div>

                <div class="glass-card" style="margin-bottom:15px; padding:15px;">
                    <span class="input-label">${t('memo')}</span>
                    <div style="font-size:1rem; color:var(--text-dim); line-height:1.5; min-height:20px;">${word.memo ||
                        '-'}</div>
                </div>

                <div style="margin-bottom:25px;">
                    <span class="input-label" style="margin-bottom:8px;">${t('tags')}</span>
                    <div style="display:flex; flex-wrap:wrap;">${tagHtml}</div>
                </div>

                <div style="display:flex; gap:10px;">
                    <button id="btn-detail-dict" class="glass-btn primary"
                        style="flex:1; background:linear-gradient(135deg, #03C75A, #02b350); border:none;">
                        ${t('dict_search')}
                    </button>
                </div>
                <div class="modal-footer-gap"></div>
            </div>
            `;

        </div>
    </div>


    <script>


        /* --- [추가] Service Worker 등록 로직 --- */
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => {
                    console.log('SW Registered:', reg);

                    reg.onupdatefound = () => {
                        const installingWorker = reg.installing;
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // [수정] 번역 함수 t() 사용
                                if (confirm(t('update_found'))) {
                                    window.location.reload();
                                }
                            }
                        };
                    };
                })
                .catch(err => console.log('SW Registration Fail:', err));
        }
        /* --- [JS 교체] 다국어 번역 데이터베이스 (5개국어) --- */
        /* --- [JS 수정] 1. 다국어 데이터 및 통합 번역 함수 --- */
        const TRANSLATIONS = {
            'ko': {
                app_name: "PrismV",
                welcome_title: "환영합니다!",
                welcome_desc: "당신의 단어를 기록하고, 완벽하게 기억하세요.",
                start: "시작하기",
                import_data: "📂 기존 정보 불러오기",
                setup_lang: "언어 설정 🌐",
                setup_lang_desc: "모국어와 학습할 언어를 선택하세요.",
                mother_tongue: "나의 모국어",
                target_lang: "학습할 언어 추가",
                setup_theme: "테마 설정 🎨",
                setup_theme_desc: "눈이 편안한 모드를 선택하세요.",
                preview: "미리보기",
                finish_setup: "설정 완료",
                filter_fav: "즐겨찾기",
                filter_weak: "취약 단어",
                filter_last: "직전 오답",
                dashboard: "대시보드",
                show_all: "더보기",
                language: "언어",
                fold: "접기",
                settings: "설정",
                my_learning_status: "나의 학습 현황",
                add_lang: "언어 추가",
                total_words: "단어수",
                accuracy: "정답률",
                review_status: "복습",
                exam_count: "시험횟수",
                today: "오늘",
                days_ago: "{n}일 전",
                click_analyze: "클릭하여 분석 >",
                search_placeholder: "단어 또는 뜻 검색...",
                category_all: "전체",
                category_term: "단어",
                category_mean: "뜻",
                search_result_info: "언어: {l} > 그룹: {g} > {i}번째",
                no_search_results: "검색 결과가 없습니다.",
                my_vocas: "나의 단어장 📂",
                smart_group: "스마트 그룹 (Auto)",
                smart_last_wrong: "직전 오답 노트",
                smart_freq_wrong: "취약 단어 (3회+)",
                manage: "관리",
                done: "완료",
                empty_group: "생성된 단어장이 없습니다.<br>우측 하단 + 버튼을 눌러 추가하세요.",
                empty_word: "단어가 없습니다.<br>'+' 버튼으로 추가하세요.",
                new_group_title: "새 단어장 만들기 📁",
                new_group_desc: "단어장의 이름과 설명을 입력하세요.",
                grp_name: "단어장 이름",
                grp_desc: "단어장 설명 (개요)",
                create: "생성하기",
                cancel: "취소",
                save: "저장",
                save_cont: "저장 & 계속",
                word_new: "새 단어 추가",
                word_edit: "단어 수정",
                term: "단어/표현",
                pron: "발음/읽는 법",
                mean: "뜻/의미",
                memo: "메모 (예문)",
                tags: "태그",
                quiz_setup: "퀴즈 설정 📝",
                tts_option: "🔊 TTS(음성) 듣기",
                random_option: "🔀 랜덤 순서 (이어하기 불가)",
                quiz_type_select: "출제 유형 선택 (다중 선택 가능)",
                quiz_start: "처음부터 시작",
                quiz_cont: "이어서 시작",
                quiz_start_idx: "이 단어부터 퀴즈 시작",
                alert_input: "단어와 뜻을 입력하세요",
                confirm_del: "삭제하시겠습니까?",
                restore_confirm: "기존 데이터를 덮어쓰고 복원하시겠습니까? \n복원 후 앱이 재시작됩니다.",
                reset_confirm: "정말 모든 데이터를 초기화 하시겠습니까?",
                theme_dark: "Dark 🌙",
                theme_light: "Light ☀️",
                backup_data: "💾 데이터 백업 (.json)",
                load_data: "📂 데이터 불러오기",
                reset_data: "⚠️ 초기화",
                check_update: "🔄 업데이트 확인",
                app_info: "앱 정보",
                curr_ver: "현재 최신 버전입니다.",
                word_detail: "단어 상세 정보",
                dict_search: "사전",
                graph_title: "📈 성적 변화 추이",
                no_data_graph: "데이터 부족",
                need_more_exam: "시험을 2회 이상 봐야 그래프가 생성됩니다.",
                lang_manage_title: "언어 추가/관리",
                lang_manage_desc: "국기를 클릭하여 학습 언어를 추가하세요.",
                close: "닫기",
                lang_status_on: "활성됨 (ON)",
                lang_status_off: "숨김 (OFF)",
                lang_status_add: "추가하기",
                lang_select: "선택됨",
                times: "회차",
                score_suffix: "점",
                quiz_question: "문제",
                quiz_result: "결과",
                quiz_correct: "정답입니다! ⭕",
                quiz_correct1: "모두 정답입니다 ⭕",
                delete: "삭제",
                quiz_wrong: "오답입니다 ❌",
                quiz_next: "다음 (Next) ▶",
                quiz_finish_alert: "퀴즈 완료! 🎉\n정답률: {n}%",
                stat_min_try: "최소회독",
                stat_avg_acc: "평균정답",
                stat_weak: "취약",
                no_matching_word: "해당하는 단어가 없습니다.",
                recent_quiz: "최근 퀴즈",
                recent_mod: "최근 수정", update_found: "새로운 업데이트가 있습니다. 재시작 하시겠습니까?",
                update_checked: "업데이트를 확인했습니다.\n새 버전이 있다면 잠시 후 알림이 뜹니다.",
                update_fail: "업데이트 확인 실패: 오프라인 상태이거나 오류가 발생했습니다.",
                sw_unsupported: "이 브라우저는 앱 업데이트 기능을 지원하지 않습니다.",

                q_type_sel_l2m: "단어 보고 뜻 고르기",
                q_type_sel_m2l: "뜻 보고 단어 고르기",
                q_type_typ_spell: "철자 직접 입력하기",
                q_type_tts_dict: "발음 듣고 뜻 맞추기",
                q_type_j_sel_k2h: "단어 보고 읽는 법(가나)",
                q_type_j_sel_m2k: "뜻 보고 단어 고르기",
                q_type_j_typ_spell: "철자 직접 입력하기",
                q_type_j_wri_chk: "직접 손으로 써보기",

                self_check_hint: "종이에 쓰거나 생각해보세요.",
                check_answer: "정답 확인",
                submit: "확인",
                correct: "맞음",
                wrong: "틀림",
                input_placeholder: "정답 입력"
            },
            'en': {
                app_name: "PrismV",
                welcome_title: "Welcome!",
                welcome_desc: "Record your words and remember them perfectly.",
                start: "Get Started",
                import_data: "📂 Import Data",
                setup_lang: "Language Setup 🌐",
                setup_lang_desc: "Select your native and target languages.",
                mother_tongue: "Native Language",
                target_lang: "Add Target Language",
                setup_theme: "Theme Setup 🎨",
                setup_theme_desc: "Choose a comfortable mode.",
                preview: "Preview",
                finish_setup: "Finish Setup",
                dashboard: "Dashboard",
                settings: "Settings",
                my_learning_status: "My learning status",
                add_lang: "Add Language",
                language: "Language",
                total_words: "Words",
                show_all: "Show All",
                fold: "Fold",
                accuracy: "Accuracy",
                review_status: "Review",
                exam_count: "Exams",
                today: "Today",
                search_placeholder: "Search term or meaning...",
                category_all: "All",
                category_term: "Term",
                category_mean: "Meaning",
                search_result_info: "Lang: {l} > Grp: {g} > #{i}",
                no_search_results: "No results found.",
                days_ago: "{n} days ago",
                click_analyze: "Click to Analyze >",
                my_vocas: "My Vocabularies 📂",
                filter_fav: "Favorites",
                filter_weak: "Weak Words",
                filter_last: "Last Wrong",
                smart_group: "Smart Group (Auto)",
                smart_last_wrong: "Last Wrong",
                delete: "Delete",
                smart_freq_wrong: "Freq. Wrong (3+)",
                manage: "Edit",
                done: "Done",
                empty_group: "No groups created.<br>Tap + to add one.",
                empty_word: "No words here.<br>Tap '+' to add.",
                new_group_title: "Create Group 📁",
                new_group_desc: "Enter group name and description.",
                grp_name: "Group Name",
                grp_desc: "Description",
                create: "Create",
                cancel: "Cancel",
                save: "Save",
                save_cont: "Save & Next",
                word_new: "Add New Word",
                word_edit: "Edit Word",
                recent_quiz: "Last Quiz",
                recent_mod: "Last Edit",
                term: "Term",
                pron: "Pronunciation",
                mean: "Meaning",
                memo: "Memo (Example)",
                tags: "Tags",
                quiz_setup: "Quiz Setup 📝",
                tts_option: "🔊 Enable TTS",
                random_option: "🔀 Random (No Resume)",
                quiz_type_select: "Select Quiz Types",
                quiz_start: "Start New",
                quiz_cont: "Continue",
                quiz_start_idx: "Start from here",
                alert_input: "Please input Term and Meaning",
                confirm_del: "Are you sure?",
                restore_confirm: "Overwrite data and restore? App will restart.",
                reset_confirm: "Are you sure you want to reset all data?",
                update_found: "New update available. Reload now?",
                update_checked: "Checked for updates.\nYou will be notified if a new version exists.",
                update_fail: "Update check failed. Offline or error occurred.",
                sw_unsupported: "This browser does not support app updates.",
                theme_dark: "Dark 🌙",
                theme_light: "Light ☀️",
                backup_data: "💾 Backup Data",
                load_data: "📂 Import Data",
                reset_data: "⚠️ Reset All",
                check_update: "🔄 Check Update",
                app_info: "App Info",
                curr_ver: "You are up to date.",
                word_detail: "Word Details",
                dict_search: "Dictionary",
                graph_title: "📈 Progress (Scrollable)",
                no_data_graph: "Not Enough Data",
                need_more_exam: "Take at least 2 exams to see the graph.",
                lang_manage_title: "Manage Languages",
                lang_manage_desc: "Click flags to add/remove languages.",
                stat_min_try: "Min Tries",
                stat_avg_acc: "Avg Acc.",
                stat_weak: "Weak",
                no_matching_word: "No matching words found.",
                close: "Close",
                lang_status_on: "Active (ON)",
                lang_status_off: "Hidden (OFF)",
                lang_status_add: "Add",
                lang_select: "Selected",
                times: "th",
                score_suffix: "pts",
                quiz_question: "Question",
                quiz_result: "Result",
                quiz_correct: "Correct! ⭕",

                quiz_correct1: "All Correct⭕",
                quiz_wrong: "Wrong ❌",
                quiz_next: "Next ▶",
                quiz_finish_alert: "Quiz Completed! 🎉\nAccuracy: {n}%",

                q_type_sel_l2m: "Term -> Meaning",
                q_type_sel_m2l: "Meaning -> Term",
                q_type_typ_spell: "Type Spelling",
                q_type_tts_dict: "Listen & Guess",
                q_type_j_sel_k2h: "Term -> Reading (Kana)",
                q_type_j_sel_m2k: "Meaning -> Term",
                q_type_j_typ_spell: "Type Spelling",
                q_type_j_wri_chk: "Handwriting Check",

                self_check_hint: "Write it down or think about it.",
                check_answer: "Check Answer",
                submit: "Submit",
                correct: "Correct",
                wrong: "Wrong",
                input_placeholder: "Input Answer"
            },
            'ja': {
                app_name: "PrismV",
                welcome_title: "ようこそ!",
                welcome_desc: "単語を記録して、完璧に覚えましょう。",
                start: "始める",
                import_data: "📂 データを読み込む",
                setup_lang: "言語設定 🌐",
                setup_lang_desc: "母国語と学習する言語を選択してください。",
                mother_tongue: "母国語",
                target_lang: "学習言語を追加",
                setup_theme: "テーマ設定 🎨",
                setup_theme_desc: "見やすいモードを選択してください。",
                preview: "プレビュー",
                finish_setup: "設定完了",
                my_learning_status: "学習現況",
                dashboard: "ダッシュボード",
                settings: "設定",
                show_all: "すべて表示",
                language: "言語",
                fold: "折りたたむ",
                add_lang: "言語追加",
                total_words: "単語数",
                accuracy: "正答率",
                review_status: "復習",
                exam_count: "試験回数",
                today: "今日",
                days_ago: "{n}日前",
                click_analyze: "分析を見る >",
                my_vocas: "私の単語帳 📂",
                smart_group: "スマートグループ (Auto)",
                smart_last_wrong: "直前の誤答",
                delete: "削除",
                smart_freq_wrong: "苦手単語 (3回+)",
                manage: "編集",
                done: "完了",
                recent_quiz: "最近のクイズ",
                recent_mod: "最近の修正",
                empty_group: "単語帳がありません。<br>+ボタンで追加してください。",
                empty_word: "単語がありません。<br>'+'ボタンで追加してください。",
                new_group_title: "単語帳を作成 📁",
                new_group_desc: "単語帳の名前と説明を入力してください。",
                update_found: "新しいアップデートがあります。再起動しますか？",
                update_checked: "アップデートを確認しました。\n新しいバージョンがあれば通知されます。",
                update_fail: "確認に失敗しました。オフラインかエラーが発生しました。",
                sw_unsupported: "このブラウザはアプリの更新をサポートしていません。",
                filter_fav: "お気に入り",
                filter_weak: "苦手単語",
                filter_last: "直前の誤答",
                grp_name: "単語帳名",
                grp_desc: "説明 (任意)",
                create: "作成",
                cancel: "キャンセル",
                save: "保存",
                save_cont: "保存して継続",
                word_new: "単語追加",
                word_edit: "単語編集",
                term: "単語/表現",
                pron: "発音",
                mean: "意味",
                memo: "メモ (例文)",
                tags: "タグ",
                quiz_setup: "クイズ設定 📝",
                tts_option: "🔊 音声(TTS)を聞く",
                random_option: "🔀 ランダム (継続不可)",
                quiz_type_select: "出題タイプ選択",
                quiz_start: "最初から",
                quiz_cont: "続きから",
                quiz_start_idx: "ここから開始",
                alert_input: "単語と意味を入力してください",
                confirm_del: "削除しますか？",
                restore_confirm: "データを上書きして復元しますか？アプリが再起動します。",
                reset_confirm: "本当にすべてのデータを初期化しますか？",
                theme_dark: "Dark 🌙",
                theme_light: "Light ☀️",
                backup_data: "💾 バックアップ",
                load_data: "📂 データ読込",
                reset_data: "⚠️ 初期化",
                check_update: "🔄 更新確認",
                app_info: "アプリ情報",
                curr_ver: "最新バージョンです。",
                word_detail: "単語詳細",
                dict_search: "辞書",
                graph_title: "📈 成績推移 (スクロール)",
                no_data_graph: "データ不足",
                need_more_exam: "グラフ表示には2回以上の試験が必要です。",
                lang_manage_title: "言語管理",
                lang_manage_desc: "国旗をクリックして言語を追加します。",
                close: "閉じる",
                lang_status_on: "有効 (ON)",
                lang_status_off: "非表示 (OFF)",
                stat_min_try: "最小回読",
                stat_avg_acc: "平均正答",
                stat_weak: "弱点",
                no_matching_word: "該当する単語がありません。",
                lang_status_add: "追加",
                lang_select: "選択済み",
                times: "回目",
                score_suffix: "点",
                quiz_question: "問題",
                quiz_result: "結果",
                quiz_correct: "正解です! ⭕",
                quiz_correct1: "全正解 ⭕",
                quiz_wrong: "不正解 ❌",
                quiz_next: "次へ ▶",
                quiz_finish_alert: "クイズ終了! 🎉\n正答率: {n}%",
                q_type_sel_l2m: "単語 -> 意味",
                q_type_sel_m2l: "意味 -> 単語",
                q_type_typ_spell: "スペル入力",
                q_type_tts_dict: "聞いて当てる",
                q_type_j_sel_k2h: "漢字 -> 読み方",
                q_type_j_sel_m2k: "意味 -> 単語",
                q_type_j_typ_spell: "スペル入力",
                q_type_j_wri_chk: "手書きチェック",
                self_check_hint: "紙に書くか、頭で考えてください。",
                check_answer: "答え合わせ",
                submit: "確認",
                correct: "正解",
                wrong: "不正解",
                input_placeholder: "答えを入力"
            },
            'zh': {
                app_name: "PrismV",
                welcome_title: "欢迎!",
                welcome_desc: "记录单词，完美记忆。",
                start: "开始",
                import_data: "📂 导入数据",
                setup_lang: "语言设置 🌐",
                setup_lang_desc: "选择母语和学习语言。",
                mother_tongue: "母语",
                target_lang: "添加学习语言",
                setup_theme: "主题设置 🎨",
                setup_theme_desc: "选择舒适的模式。",
                preview: "预览",
                finish_setup: "完成设置",
                dashboard: "仪表盘",
                settings: "设置",
                my_learning_status: "学习现状",
                add_lang: "添加语言",
                total_words: "单词数",
                delete: "删除",
                accuracy: "正确率",
                review_status: "复习",
                language: "语言",
                search_placeholder: "搜索单词或含义...",
                category_all: "全部",
                category_term: "单词",
                category_mean: "含义",
                search_result_info: "语言: {l} > 分组: {g} > 第{i}个",
                no_search_results: "未找到搜索结果。",
                exam_count: "测验次数",
                show_all: "查看全部",
                fold: "收起",
                today: "今天",
                days_ago: "{n}天前",
                click_analyze: "点击分析 >",
                filter_fav: "收藏",
                filter_weak: "弱项单词",
                filter_last: "上次错题",
                my_vocas: "我的词汇本 📂",
                smart_group: "智能分组 (Auto)",
                smart_last_wrong: "上次错题",
                smart_freq_wrong: "常错单词 (3+)",
                manage: "管理",
                done: "完成",
                empty_group: "没有词汇本。<br>点击+按钮添加。",
                empty_word: "没有单词。<br>点击'+'添加。",
                new_group_title: "创建词汇本 📁",
                new_group_desc: "输入名称和说明。",
                stat_min_try: "最少阅读",
                stat_avg_acc: "平均正确",
                stat_weak: "弱项",
                no_matching_word: "没有找到对应的单词。",
                update_found: "发现新版本。是否重新加载？",
                update_checked: "已检查更新。\n如果有新版本，稍后会通知您。",
                update_fail: "检查失败。离线或发生错误。",
                sw_unsupported: "此浏览器不支持应用更新。",
                grp_name: "名称",
                grp_desc: "说明",
                create: "创建",
                cancel: "取消",
                save: "保存",
                recent_quiz: "最近测验",
                recent_mod: "最近修改",
                save_cont: "保存并继续",
                word_new: "添加单词",
                word_edit: "编辑单词",
                term: "单词/表达",
                pron: "发音",
                mean: "含义",
                memo: "备注 (例句)",
                tags: "标签",
                quiz_setup: "测验设置 📝",
                tts_option: "🔊 启用语音 (TTS)",
                random_option: "🔀 随机顺序 (不可继续)",
                quiz_type_select: "选择题型",
                quiz_start: "从头开始",
                quiz_cont: "继续上次",
                quiz_start_idx: "从这里开始",
                alert_input: "请输入单词和含义",
                confirm_del: "确定删除吗？",
                restore_confirm: "恢复数据？应用将重启。",
                reset_confirm: "确定要重置所有数据吗？",
                theme_dark: "深色 🌙",
                theme_light: "浅色 ☀️",
                backup_data: "💾 备份数据",
                load_data: "📂 导入数据",
                reset_data: "⚠️ 重置所有",
                check_update: "🔄 检查更新",
                app_info: "应用信息",
                curr_ver: "已是最新版本。",
                word_detail: "单词详情",
                dict_search: "查词典",
                graph_title: "📈 成绩趋势 (可滚动)",
                no_data_graph: "数据不足",
                need_more_exam: "至少考试2次才能显示图表。",
                lang_manage_title: "语言管理",
                lang_manage_desc: "点击国旗添加或移除语言。",
                close: "关闭",
                lang_status_on: "已启用 (ON)",
                lang_status_off: "已隐藏 (OFF)",
                lang_status_add: "添加",
                lang_select: "已选择",
                times: "次",
                score_suffix: "分",
                quiz_question: "问题",
                quiz_result: "结果",
                quiz_correct: "回答正确! ⭕",

                quiz_correct1: "全正确⭕",
                quiz_wrong: "回答错误 ❌",
                quiz_next: "下一题 ▶",
                quiz_finish_alert: "测验结束! 🎉\n正确率: {n}%",
                q_type_sel_l2m: "看词选义",
                q_type_sel_m2l: "看义选词",
                q_type_typ_spell: "拼写输入",
                q_type_tts_dict: "听音辨义",
                q_type_j_sel_k2h: "看词选读音",
                q_type_j_sel_m2k: "看义选词",
                q_type_j_typ_spell: "拼写输入",
                q_type_j_wri_chk: "手写自测",
                self_check_hint: "请在纸上书写或思考答案。",
                check_answer: "检查答案",
                submit: "提交",
                correct: "正确",
                wrong: "错误",
                input_placeholder: "输入答案"
            },
            'es': {
                app_name: "PrismV",
                welcome_title: "¡Bienvenido!",
                welcome_desc: "Graba tus palabras, recuérdalas perfectamente.",
                start: "Empezar",
                import_data: "📂 Importar Datos",
                setup_lang: "Configuración 🌐",
                setup_lang_desc: "Elige tu lengua materna y objetivo.",
                mother_tongue: "Lengua Materna",
                target_lang: "Añadir Idioma",
                setup_theme: "Tema 🎨",
                setup_theme_desc: "Elige un modo cómodo.",
                preview: "Vista Previa",
                finish_setup: "Terminar",
                dashboard: "Tablero",
                settings: "Ajustes",
                my_learning_status: "Estado de aprendizaje",
                add_lang: "Añadir",
                show_all: "Ver todo",
                fold: "Plegar",
                total_words: "Palabras",
                accuracy: "Precisión",
                review_status: "Repaso",
                exam_count: "Exámenes",
                language: "Idioma",
                search_placeholder: "Buscar palabra o significado...",
                category_all: "Todos",
                category_term: "Término",
                category_mean: "Significado",
                search_result_info: "Idioma: {l} > Grupo: {g} > Nº {i}",
                no_search_results: "No se encontraron resultados.",
                today: "Hoy",
                days_ago: "Hace {n} días",
                click_analyze: "Analizar >",
                my_vocas: "Mis Vocabularios 📂",
                delete: "Eliminar",
                filter_fav: "Favoritos",
                filter_weak: "Palabras débiles",
                filter_last: "Último error",
                smart_group: "Grupo Inteligente",
                smart_last_wrong: "Último Error",
                smart_freq_wrong: "Frecuente (3+)",
                manage: "Editar",
                done: "Listo",
                empty_group: "No hay grupos.<br>Toca + para añadir.",
                empty_word: "No hay palabras.<br>Toca '+' para añadir.",
                new_group_title: "Crear Grupo 📁",
                new_group_desc: "Introduce nombre y descripción.",
                update_found: "Nueva actualización disponible. ¿Recargar ahora?",
                update_checked: "Buscando actualizaciones.\nSe le notificará si existe una nueva versión.",
                update_fail: "Error al buscar actualizaciones. Sin conexión o error.",
                sw_unsupported: "Este navegador no admite actualizaciones de aplicaciones.",
                grp_name: "Nombre",
                grp_desc: "Descripción",
                create: "Crear",
                cancel: "Cancelar",
                save: "Guardar",
                recent_quiz: "Último Quiz",
                recent_mod: "Última Edición",
                save_cont: "Guardar y Seguir",
                word_new: "Añadir Palabra",
                word_edit: "Editar Palabra",
                term: "Término",
                pron: "Pronunciación",
                mean: "Significado",
                memo: "Memo (Ejemplo)",
                tags: "Etiquetas",
                quiz_setup: "Config. Quiz 📝",
                tts_option: "🔊 Activar TTS",
                random_option: "🔀 Aleatorio (No Resume)",
                quiz_type_select: "Tipos de Pregunta",
                quiz_start: "Empezar",
                quiz_cont: "Continuar",
                quiz_start_idx: "Empezar aquí",
                alert_input: "Por favor, introduce término y significado",
                confirm_del: "¿Estás seguro?",
                restore_confirm: "¿Sobrescribir datos y restaurar? Se reiniciará.",
                reset_confirm: "¿Estás seguro de restablecer todo?",
                theme_dark: "Oscuro 🌙",
                theme_light: "Claro ☀️",
                stat_min_try: "Intentos",
                stat_avg_acc: "Promedio",
                stat_weak: "Débil",
                no_matching_word: "No se encontraron palabras.",
                backup_data: "💾 Copia de Seguridad",
                load_data: "📂 Importar",
                reset_data: "⚠️ Restablecer",
                check_update: "🔄 Actualizar",
                app_info: "Info App",
                curr_ver: "Está actualizado.",
                word_detail: "Detalles",
                dict_search: "Diccionario",
                graph_title: "📈 Progreso (Desplazable)",
                no_data_graph: "Faltan Datos",
                need_more_exam: "Realiza al menos 2 exámenes.",
                lang_manage_title: "Gestionar Idiomas",
                lang_manage_desc: "Haz clic en las banderas para añadir.",
                close: "Cerrar",
                lang_status_on: "Activo (ON)",
                lang_status_off: "Oculto (OFF)",
                lang_status_add: "Añadir",
                lang_select: "Seleccionado",
                times: "º",
                score_suffix: " pts",
                quiz_question: "Pregunta",
                quiz_result: "Resultado",
                quiz_correct: "¡Correcto! ⭕",
                quiz_correct1: "Eso es todo⭕",
                quiz_wrong: "Incorrecto ❌",
                quiz_next: "Siguiente ▶",
                quiz_finish_alert: "¡Quiz Completado! 🎉\nPrecisión: {n}%",
                q_type_sel_l2m: "Término -> Significado",
                q_type_sel_m2l: "Significado -> Término",
                q_type_typ_spell: "Escribir",
                q_type_tts_dict: "Escuchar",
                q_type_j_sel_k2h: "Lectura (Kana)",
                q_type_j_sel_m2k: "Significado -> Término",
                q_type_j_typ_spell: "Escribir",
                q_type_j_wri_chk: "Escritura a mano",
                self_check_hint: "Escríbelo o piénsalo.",
                check_answer: "Comprobar",
                submit: "Enviar",
                correct: "Correcto",
                wrong: "Incorrecto",
                input_placeholder: "Escribe la respuesta"
            }
        };

        /* --- 번역 헬퍼 함수 (통합 및 수정됨) --- */
        function t(key, params = {}) {
            // 1. 현재 설정된 언어 가져오기 (기본값 ko)
            const lang = (appData && appData.config && appData.config.sysLang) ? appData.config.sysLang : 'ko';

            // 2. 해당 언어에 키가 없으면 -> 영어 -> 한국어 -> 키 자체 순으로 폴백
            let text = TRANSLATIONS[lang]?.[key] ||
                TRANSLATIONS['en']?.[key] ||
                TRANSLATIONS['ko']?.[key] ||
                key;

            // 3. {n} 형태의 파라미터 치환
            Object.keys(params).forEach(p => {
                text = text.replace(`{${p}}`, params[p]);
            });
            return text;
        }


        // --- Core Constants ---
        const STORE_KEY = "prism_voca_data_v2";
        // 지원 언어 목록 (엄격한 사전 연동을 위해 제한)
        const SUPPORTED_LANGS = {
            'ko': { name: '한국어', flag: '\uD83C\uDDF0\uD83C\uDDF7', url: 'https://ko.dict.naver.com/#/search?query=' }, // 🇰🇷 (KR)
            'en': { name: 'English', flag: '\uD83C\uDDFA\uD83C\uDDF8', url: 'https://en.dict.naver.com/#/search?query=' }, // 🇺🇸 (US)
            'ja': { name: '日本語', flag: '\uD83C\uDDEF\uD83C\uDDF5', url: 'https://ja.dict.naver.com/#/search?query=' }, // 🇯🇵 (JP)
            'es': { name: 'Español', flag: '\uD83C\uDDEA\uD83C\uDDF8', url: 'https://dict.naver.com/esko/search?query=' }, // 🇪🇸 (ES)
            'zh': { name: '中文', flag: '\uD83C\uDDE8\uD83C\uDDF3', url: 'https://zh.dict.naver.com/#/search?query=' }  // 🇨🇳 (CN)
        };

        // --- [데이터 추가] 퀴즈 타입 및 설정 정의 ---
        // 기존 SUPPORTED_LANGS에 quizConfig 속성을 확장합니다. (기존 코드 아래에 덮어쓰기 로직 추가)

        const QUIZ_TYPES = {
            // 1. 공통/영어권 유형
            SEL_L2M: { id: 'sel_l2m', label: '단어 보고 뜻 고르기', tts: false },
            SEL_M2L: { id: 'sel_m2l', label: '뜻 보고 단어 고르기', tts: false },
            TYP_SPELL: { id: 'typ_spell', label: '스펠링 직접 입력하기', tts: false },
            TTS_DICT: { id: 'tts_dict', label: '발음 듣고 뜻 맞추기', tts: true },

            // 2. 일본어 전용 유형
            J_SEL_K2H: { id: 'j_sel_k2h', label: '단어 보고 읽는 법 고르기', tts: false },
            J_SEL_M2K: { id: 'j_sel_m2k', label: '뜻 보고 단어 고르기', tts: false },
            J_TYP_SPELL: { id: 'j_typ_spell', label: '철자 직접 입력하기', tts: false },
            J_WRI_CHK: { id: 'j_wri_chk', label: '직접 손으로 써보기', tts: false }
        };

        // 언어별 지원 퀴즈 매핑
        const LANG_QUIZ_MAP = {
            'ko': [QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.SEL_M2L, QUIZ_TYPES.TTS_DICT], // 한국어 학습시
            'en': [QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.SEL_M2L, QUIZ_TYPES.TYP_SPELL, QUIZ_TYPES.TTS_DICT],
            'es': [QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.SEL_M2L, QUIZ_TYPES.TYP_SPELL, QUIZ_TYPES.TTS_DICT],
            'zh': [QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.SEL_M2L, QUIZ_TYPES.TTS_DICT, QUIZ_TYPES.J_TYP_SPELL], // 중국어
            'ja': [QUIZ_TYPES.J_SEL_K2H, QUIZ_TYPES.J_SEL_M2K, QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.TTS_DICT, QUIZ_TYPES.J_WRI_CHK, QUIZ_TYPES.J_TYP_SPELL],
            'default': [QUIZ_TYPES.SEL_L2M, QUIZ_TYPES.SEL_M2L, QUIZ_TYPES.TTS_DICT]
        };

        let quizSourceData = null;

        // 퀴즈 상태 전역 변수
        let quizSession = {
            active: false,
            queue: [],      // 문제로 출제될 단어들
            cursor: 0,      // 현재 몇 번째인지
            correctCnt: 0,
            config: {},     // { useTTS, types, ... }
            currentQType: null
        };

        // --- Global State ---
        let appData = {
            config: { theme: 'dark', sysLang: 'ko', setupDone: false },
            myLangs: [], // Example: [{code: 'ja', id: 1}, {code: 'en', id: 2}]
            groups: [],  // { id, langId, title, type: 'date'|'custom'|'auto', createdAt }
            words: []    // { id, groupId, term, mean, ... , correctCount, wrongCount }
        };
        let isSmartGridExpanded = false;

        let currentTab = 'home'; // 'home', 'settings', or langId (e.g. 1, 2)
        let currentGroupId = null; // 그룹 내부 진입 시 ID

        // --- Global State ---
        let currentSmartView = null; // { mode: 'tag'|'wrong_last'|'wrong_freq', value: '...' }
        let isGroupManageMode = false;

        let currentWordFilter = 'all'; // all, fav, weak, wrong_last

        function setWordFilter(filterType) {
            if (currentWordFilter === filterType) currentWordFilter = 'all';
            else currentWordFilter = filterType;

            if (currentGroupId && !currentSmartView) {
                const g = appData.groups.find(grp => grp.id === currentGroupId);
                if (g) renderGroupDetail(document.getElementById('main-view-area'), g.langId, currentGroupId);
            }
        }

        // [오류 해결] updateStarUI 함수를 toggleFavorite와 함께 전역 범위에 선언
        function updateStarUI(wordId, isFav) {
            // 1. 리스트의 별 업데이트
            const starWrapper = document.getElementById(`star-btn-${wordId}`);
            if (starWrapper) {
                if (isFav) starWrapper.classList.add('active');
                else starWrapper.classList.remove('active');
            }
            // 2. 상세 모달 내 버튼 업데이트
            const modalBtn = document.getElementById('btn-modal-fav');
            if (modalBtn) {
                if (isFav) {
                    modalBtn.style.color = '#FFD700';
                    modalBtn.style.backgroundColor = 'rgba(255, 239, 11,0.1)';
                    modalBtn.style.borderColor = '#FFD700';
                    modalBtn.innerText = '★';
                } else {
                    modalBtn.style.color = 'var(--text-dim)';
                    modalBtn.style.backgroundColor = 'rgba(255, 255, 255,0)';
                    modalBtn.style.borderColor = 'var(--glass-border)';
                    modalBtn.innerText = '☆';
                }
            }
        }

        function toggleFavorite(wordId, event) {
            if (event) event.stopPropagation(); // 클릭 이벤트 전파 방지
            const idNum = Number(wordId);
            const word = appData.words.find(w => w.id === idNum);

            if (word) {
                // 기존 값 반전 (undefined일 경우 true로)
                word.isFav = !word.isFav;
                saveData();

                // UI 즉시 갱신
                updateStarUI(idNum, word.isFav);
            }
        }

        // --- Initialization ---
        // --- Initialization ---
        window.onload = () => {
            loadData();

            // [추가] 앱 시작 시 초기 히스토리 상태 정의 (Depth 0: Home)
            history.replaceState({ level: 0, view: 'home' }, null, '');

            if (!appData.config.setupDone) {
                initSetup();
            } else {
                renderApp();
            }
        };

        /* --- [JS 수정] 뒤로가기 핸들러 (안전 장치 추가) --- */
        window.onpopstate = (event) => {
            // 1. 현재 활성화된 모달 찾기
            const activeModal = document.querySelector('.modal-overlay.active');

            if (activeModal) {
                // [수정] ID가 정확히 'setup-popup'일 때만 막음 
                // (finishSetup에서 ID를 바꿨으므로 완료 후에는 이 조건문에 걸리지 않음)
                if (activeModal.id === 'setup-popup' && !appData.config.setupDone) {
                    history.pushState({ level: 3, view: 'modal', modalId: 'setup-popup' }, null, '');
                    return;
                }

                // 그 외 일반 모달은 정상적으로 닫기
                activeModal.classList.add('closing');
                activeModal.classList.remove('active');
                setTimeout(() => {
                    activeModal.classList.remove('closing');
                    activeModal.style.display = '';
                    activeModal.style.opacity = '';
                }, 300);
                return;
            }

            // 2. 퀴즈 화면 닫기 처리
            const quizScreen = document.getElementById('quiz-screen');
            if (quizScreen && quizScreen.style.display === 'flex') {
                saveQuizProgress();
                quizSession.active = false;
                quizScreen.style.display = 'none';
                renderApp();
                return;
            }

            // 3. 일반 네비게이션 처리 (History State 복원)
            if (event.state) {
                const state = event.state;
                if (state.view === 'home') {
                    currentTab = 'home';
                    currentGroupId = null;
                    currentSmartView = null;
                    isManageMode = false;
                    isGroupManageMode = false;
                } else if (state.view === 'lang') {
                    currentTab = state.tabId;
                    currentGroupId = null;
                    currentSmartView = null;
                    isManageMode = false;
                } else if (state.view === 'group') {
                    currentGroupId = state.groupId;
                    isManageMode = false;
                } else if (state.view === 'smart') {
                    currentSmartView = state.data;
                }
                renderApp();
            } else {
                currentTab = 'home';
                currentGroupId = null;
                renderApp();
            }
        };

        function loadData() {
            const raw = localStorage.getItem(STORE_KEY);
            if (raw) appData = JSON.parse(raw);
            else {
                // 기본값 없음, 초기 상태
            }
            // 테마 적용
            applyTheme(appData.config.theme);
        }

        function saveData() {
            localStorage.setItem(STORE_KEY, JSON.stringify(appData));
        }

        function finishSetup() {
            // 1. 설정 완료 데이터 저장
            appData.config.setupDone = true;
            saveData();

            // 2. 모달 요소 가져오기
            const modal = document.getElementById('setup-popup');

            if (modal) {
                // [핵심] 모달의 ID를 변경하여 onpopstate의 '뒤로가기 방지 감지'를 무력화시킴
                modal.id = 'setup-popup-closed';

                // 애니메이션 없이 즉시 숨김 (가장 확실한 방법)
                modal.style.display = 'none';
                modal.classList.remove('active');
            }

            // 3. 히스토리 스택 정리 (현재 상태를 'home'으로 덮어씀)
            history.replaceState({ level: 0, view: 'home' }, null, '');

            // 4. 메인 화면 렌더링
            renderApp();
        }

        function applyTheme(theme) { /* 기존 CSS 클래스 토글 로직 유지 */
            document.body.className = theme === 'light' ? 'light-mode' : 'dark-mode';
        }

        // --- Main Render Controller ---
        function renderApp() {
            renderSideNav();
            renderMainContent();
        }

        // --- [UI] Side Navigation (ShiftV Style) ---
        // --- [수정] Side Navigation Render ---
        /* --- renderSideNav 수정 --- */
        function renderSideNav() {
            const nav = document.getElementById('app-nav-bar');

            let html = `
        <button class="tab-button ${currentTab === 'home' ? 'active' : ''}" onclick="navigate('home')">
            <div class="tab-icon-area"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <span class="tab-label">${t('dashboard')}</span>
        </button>
    `;

            appData.myLangs.forEach(lang => {
                if (lang.isVisible === false) return;
                const info = SUPPORTED_LANGS[lang.code];
                const isActive = currentTab == lang.id ? 'active' : '';
                html += `
        <button class="tab-button ${isActive}" onclick="navigate(${lang.id})">
            <div class="tab-icon-area">${info.flag}</div>
            <span class="tab-label">${info.name}</span>
        </button>`;
            });

            html += `
        <div style="flex:1;"></div> 
        
        <button class="tab-button" onclick="openAddLangModal()" style="color:var(--accent);">
            <div class="tab-icon-area"><svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg></div>
            <span class="tab-label">${t('add_lang')}</span>
        </button>
        
        <button class="tab-button ${currentTab === 'settings' ? 'active' : ''}" onclick="navigate('settings')">
            <div class="tab-icon-area">
                <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.91,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.43-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.57,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
            </div>
            <span class="tab-label">${t('settings')}</span>
        </button>
    `;
            nav.innerHTML = html;
        }

        /* --- [JS 수정] 언어 추가 모달 (번역 적용) --- */
        function openAddLangModal() {
            const modalId = 'modal-add-lang';
            const container = document.getElementById('flag-selection-area');
            if (!container) return;

            // 헤더 타이틀
            const headerTitle = document.querySelector('#modal-add-lang h3');
            if (headerTitle) headerTitle.innerText = t('lang_manage_title');

            // [추가] 모달 설명 텍스트 번역
            const desc = document.querySelector('#modal-add-lang .desc');
            if (desc) desc.innerText = t('lang_manage_desc');

            // [추가] 닫기 버튼 텍스트 번역
            const closeBtn = document.querySelector('#modal-add-lang .glass-btn');
            if (closeBtn) closeBtn.innerText = t('close');

            let html = '';
            Object.keys(SUPPORTED_LANGS).forEach(code => {
                const langInfo = SUPPORTED_LANGS[code];
                const existingLang = appData.myLangs.find(my => my.code === code);
                const isAdded = !!existingLang;
                const isVisible = existingLang ? existingLang.isVisible : false;

                let cardStyle = '';
                let statusText = t('lang_status_add');
                let statusColor = 'var(--accent)';

                if (isAdded && isVisible) {
                    cardStyle = 'border: 2px solid var(--primary); background: rgba(255, 143, 205, 0.1);';
                    statusText = t('lang_status_on');
                    statusColor = 'var(--primary)';
                } else if (isAdded && !isVisible) {
                    cardStyle = 'border: 1px dashed var(--text-dim); opacity: 0.6;';
                    statusText = t('lang_status_off');
                    statusColor = 'var(--text-dim)';
                }

                html += `
        <div class="flag-option" style="${cardStyle}; width:100%; margin:0;" onclick="toggleLang('${code}')">
            <div class="flag-icon">${langInfo.flag}</div>
            <div class="flag-name" style="font-weight:bold; margin-top:5px;">${langInfo.name}</div>
            <div style="font-size:0.8rem; color:${statusColor}; margin-top:2px;">${statusText}</div>
        </div>`;
            });

            container.innerHTML = html;
            openModalWithAnim(modalId);
        }



        // --- [수정] 언어 토글 로직 (Issue 3 해결) ---
        function toggleLang(code) {
            const existingIndex = appData.myLangs.findIndex(my => my.code === code);

            if (existingIndex > -1) {
                // 이미 존재함 -> visibility 토글
                // (주의: 기존 데이터 appData.myLangs의 요소에 isVisible 속성이 없을 수 있으므로 체크)
                const currentVisibility = appData.myLangs[existingIndex].isVisible !== false; // 기본값 true 취급

                // 상태 반전
                appData.myLangs[existingIndex].isVisible = !currentVisibility;

            } else {
                // 새로 추가
                appData.myLangs.push({
                    id: Date.now(),
                    code: code,
                    createdAt: Date.now(),
                    isVisible: true // 기본적으로 보임
                });
            }

            saveData();
            openAddLangModal(); // 상태 반영을 위해 모달 다시 그리기 (혹은 UI만 업데이트)
            renderSideNav();    // 사이드바 갱신
        }

        function navigate(target) {
            if (currentTab === target && !currentGroupId && !currentSmartView) return;

            currentTab = target;
            currentGroupId = null;
            currentSmartView = null;

            // [수정] 탭 이동 시 기본 상태 설정
            if (target === 'home') {
                updateFabState('home'); // 홈 탭 -> 원형
            } else if (target === 'settings') {
                updateFabState('hidden'); // 설정 탭 -> 숨김
            } else {
                // 언어 탭 (숫자 ID) -> 알약형
                updateFabState('expanded');
            }

            if (target === 'home' || target === 'settings') {
                history.pushState({ level: 1, view: target === 'home' ? 'home' : 'settings' }, null, '');
            } else {
                history.pushState({ level: 1, view: 'lang', tabId: target }, null, '');
            }

            renderApp();
        }

        // --- [UI] Main View Controller ---
        function renderMainContent() {
            const viewArea = document.getElementById('main-view-area');

            if (currentTab === 'home') return renderHomeDashboard(viewArea);
            if (currentTab === 'settings') return renderSettings(viewArea);
            if (typeof currentTab === 'number') return renderLanguageView(viewArea, currentTab);
        }

        /* renderSettings 함수 전체를 이 코드로 교체하세요 */

        /* --- renderSettings 수정 --- */
        function renderSettings(container) {
            const isDark = appData.config.theme === 'dark';
            const logoSrc = getLogoSrc(); // 로고 경로

            let darkBtnStyle = '';
            let lightBtnStyle = '';

            const transition = "transition: all 0.3s ease;";

            // 스타일 정의
            if (isDark) {
                darkBtnStyle = `
            flex:1; 
            background: rgba(81, 81, 187, 0.1); 
            color: rgba(255, 255, 255, 0.9); 
            border: 3px solid rgba(81, 81, 187, 0.1); ${transition}
        `;
                lightBtnStyle = `
            flex:1; 
            background: rgba(81, 81, 187, 0.2); 
            color: rgba(255, 255, 255, 0.9); 
            border: 1px solid rgba(81, 81, 187, 0.3); ${transition}
        `;
            } else {
                darkBtnStyle = `
            flex:1; 
            background: rgba(255, 156, 207, 0.1); 
            color: rgba(0, 0, 0, 0.8); 
            border: 1px solid rgba(255, 156, 207, 0.3); ${transition}
        `;
                lightBtnStyle = `
            flex:1; 
            background: rgba(255, 205, 231, 0.1); 
            color: rgba(0, 0, 0, 0.8); 
            border: 2px solid rgba(255, 205, 231, 0.3); ${transition}
        `;
            }

            // [핵심 수정] 가장 바깥쪽을 감싸는 <div> 추가 (width: 100% 및 column 정렬 강제)
            container.innerHTML = `
    <div style="width: 100%; display: flex; flex-direction: column;">
        <div class="logo-container">
            <img src="${logoSrc}" class="app-logo" id="logo-main" alt="PrismV Logo">
        </div>
        <h2 style="margin:0;">${t('settings')} ⚙️</h2>
        
        <div class="glass-card" style="margin-bottom: 20px;">
            <h3>${t('setup_lang')}</h3>
            <label style="display:block; margin-bottom:5px; color:var(--text-dim);">${t('mother_tongue')}</label>
            <select id="setting-sys-lang" onchange="updateSysLang(this.value)">
                <option value="ko">한국어 (Korean)</option>
                <option value="en">English</option>
                <option value="ja">日本語</option>
                <option value="zh">中文 (Chinese)</option>
                <option value="es">Español (Spanish)</option>
            </select>

            <label style="display:block; margin-top:15px; margin-bottom:10px; color:var(--text-dim);">${t('setup_theme')}</label>
            <div style="display:flex; gap:10px;">
                <button class="glass-btn" onclick="changeTheme('dark')" style="${darkBtnStyle}">${t('theme_dark')}</button>
                <button class="glass-btn" onclick="changeTheme('light')" style="${lightBtnStyle}">${t('theme_light')}</button>
            </div>
        </div>

        <div class="glass-card" style="margin-bottom: 20px;">
            <h3>${t('backup_data')}</h3>
            <button class="glass-btn primary" onclick="downloadBackup()">${t('backup_data')}</button>
            <button class="glass-btn" onclick="triggerImport()">${t('load_data')}</button>
            <input type="file" id="file-import" style="display:none;" onchange="importData(this)">
            
            <!-- 업데이트 버튼 수정: 실제 SW 업데이트 체크 함수 호출 -->
            <button class="glass-btn" onclick="checkAppUpdate()" style="margin-top:15px; border-color:var(--primary);">${t('check_update')}</button>
            <hr style="border:0; border-top:1px solid var(--glass-border); margin:15px 0;">
            <button class="glass-btn" onclick="resetData()" style="color:var(--danger); border-color:var(--danger);">${t('reset_data')}</button>
        </div>

         <div class="glass-card">
            <h3>${t('app_info')}</h3>
            <div style="display:flex; flex-direction:column; align-items:center; gap:5px; margin-bottom:15px; text-align:center;">
                <img src="${logoSrc}" class="app-logo large" id="logo-settings-info">
                <div>
                    <div style="font-size:1.4rem; font-weight:800;">${t('app_name')}</div>
                    <div style="font-size:0.9rem; opacity:0.6;">Ver 1.0.2</div>
                </div>
            </div>
            <p class="desc" style="margin-bottom:0; text-align:center;">
                ${t('welcome_desc')}
            </p>
        </div>
        <div style="height:120px; width:100%;"></div>
    </div>`;

            setTimeout(() => {
                const sel = document.getElementById('setting-sys-lang');
                if (sel) sel.value = appData.config.sysLang;
            }, 50);
        }

        function updateSysLang(lang) {
            appData.config.sysLang = lang;
            saveData();

            // 만약 설정이 완료된 상태라면 앱 전체 리렌더링
            if (appData.config.setupDone) {
                renderApp();
            } else {
                // 설정 중이라면 모달 내용만 새로고침 (언어 반영)
                renderSetupModal();
            }
        }

        // 데이터 백업
        function downloadBackup() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(appData));
            const downloadAnchor = document.createElement('a');
            downloadAnchor.setAttribute("href", dataStr);
            downloadAnchor.setAttribute("download", "PrismV_Backup_" + new Date().toISOString().slice(0, 10) + ".json");
            document.body.appendChild(downloadAnchor);
            downloadAnchor.click();
            downloadAnchor.remove();
        }

        // 데이터 불러오기 (트리거)
        function triggerImport() {
            document.getElementById('file-import').click();
        }

        // 파일 읽기
        function importData(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const json = JSON.parse(e.target.result);
                    if (confirm(t('restore_confirm'))) {
                        appData = json;
                        saveData();
                        location.reload();
                    }
                } catch (err) {
                    alert("File Error");
                }
            };
            reader.readAsText(file);
        }

        function changeTheme(mode) {
            appData.config.theme = mode;
            saveData();
            applyTheme(mode); // CSS 테마 적용

            // [핵심 추가] 로고 이미지 실시간 교체
            const newLogoSrc = getLogoSrc();
            const logos = document.querySelectorAll('.app-logo');
            logos.forEach(img => {
                img.src = newLogoSrc;
            });

            // 설정 화면의 버튼 스타일 갱신을 위해 재 렌더링
            if (currentTab === 'settings') {
                const container = document.getElementById('main-view-area');
                renderSettings(container);
            }
        }

        // 현재 테마에 맞는 로고 경로 반환
        function getLogoSrc() {
            // 다크 모드일 때: 배경이 어두우므로 밝은 로고(PrismV_dark.png)를 쓴다고 가정 (파일명 규칙에 따름)
            // 혹은 파일명이 반대라면(다크모드용 이미지가 dark.png라면) 아래 경로를 사용
            return appData.config.theme === 'dark'
                ? './Asset/PrismV_dark.png'   // Dark Theme용 이미지
                : './Asset/PrismV_light.png'; // Light Theme용 이미지
        }

        // 1. Home View (ShiftV Widgets Style)
        function renderHomeDashboard(container) {
            let langStatsHTML = '';

            appData.myLangs.forEach(lang => {
                if (lang.isVisible === false) return;

                const info = SUPPORTED_LANGS[lang.code];
                const wordsInLang = appData.words.filter(w => w.langId === lang.id);
                const totalW = wordsInLang.length;

                let totalRate = 0;
                let ratedCount = 0;
                wordsInLang.forEach(w => {
                    if (w.stats && w.stats.total > 0) {
                        totalRate += Math.round(((w.stats.total - w.stats.wrong) / w.stats.total) * 100);
                        ratedCount++;
                    }
                });
                const avgAcc = ratedCount > 0 ? Math.round(totalRate / ratedCount) : 0;

                const groupsInLang = appData.groups.filter(g => g.langId === lang.id);
                let examCount = 0;
                let lastDate = 0;

                groupsInLang.forEach(g => {
                    if (g.quizHistory) examCount += g.quizHistory.length;
                    if (g.lastQuizDate && g.lastQuizDate > lastDate) lastDate = g.lastQuizDate;
                });

                let dDayStr = t('days_ago', { n: 0 });
                if (lastDate > 0) {
                    const diff = Date.now() - lastDate;
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    dDayStr = days === 0 ? t('today') : t('days_ago', { n: days });
                } else {
                    dDayStr = '-';
                }

                updateFabState('home');

                // [UI 개선] .lang-stat-grid에 배경색과 패딩을 추가하여 정보 그룹핑
                langStatsHTML += `
        <div class="glass-card" onclick="openLangAnalysisModal(${lang.id})" style="cursor:pointer; padding:20px; transition:0.2s;">
            <div style="display:flex; align-items:center; gap:12px; margin-bottom:15px;">
                <div style="font-size:2.2rem;">${info.flag}</div>
                <div>
                    <div style="font-size:1.2rem; font-weight:800; line-height:1.2;">${info.name}</div>
                    <div style="font-size:0.75rem; opacity:0.6; margin-top:2px;">${t('click_analyze')}</div>
                </div>
            </div>
            
            <!-- 정보 그룹핑 박스 (배경 추가) -->
            <div class="lang-stat-grid" style="background:var(--bg-dimbox); border-radius:12px; padding:15px; row-gap:10px;">
                <div class="lang-stat-item">
                    <span class="lang-stat-label" style="font-size:0.9rem; font-weight:500;">${t('total_words')}</span>
                    <span class="lang-stat-value" style="font-size:0.9rem; font-weight:700;">${totalW}</span>
                </div>
                <div class="lang-stat-item">
                    <span class="lang-stat-label" style="font-size:0.9rem; font-weight:500;">${t('accuracy')}</span>
                    <span class="lang-stat-value" style="font-size:0.9rem; color:${avgAcc >= 80 ? '#4CAF50' : (avgAcc < 50 ? '#FF5577' : 'var(--accent)')}">${avgAcc}%</span>
                </div>
                <div class="lang-stat-item">
                    <span class="lang-stat-label" style="font-size:0.9rem; font-weight:500;">${t('review_status')}</span>
                    <span class="lang-stat-value" style="font-size:0.9rem; font-weight:700;">${dDayStr}</span>
                </div>
                <div class="lang-stat-item">
                     <span class="lang-stat-label" style="font-size:0.9rem; font-weight:500;">${t('exam_count')}</span>
                     <span class="lang-stat-value" style="font-size:0.9rem; font-weight:700;">${examCount}</span>
                </div>
            </div>
        </div>`;
            });

            const addCardHTML = `
        <div class="stat-widget glass-card" onclick="openAddLangModal()" style="cursor:pointer; border:2px dashed rgba(253, 114, 177, 0.5); background:transparent; display:flex; flex-direction:column; justify-content:center; align-items:center; gap:10px; min-height:220px;">
            <div style="font-size:2.5rem; color:var(--accent); opacity:0.5;">+</div>
            <div class="stat-label1" style="font-size:0.9rem;">${t('add_lang')}</div>
        </div>
    `;

            const logoSrc = getLogoSrc();

            container.innerHTML = `
        <div class="logo-container">
            <img src="${logoSrc}" class="app-logo" id="logo-main" alt="PrismV Logo">
        </div>

        <h2>${t('my_learning_status')}</h2>
        
        <div class="dashboard-responsive-grid">
            ${langStatsHTML}
            ${addCardHTML}
        </div>
    `;
        }

        function renderRecentWordsList() {
            const recents = [...appData.words].sort((a, b) => b.created - a.created).slice(0, 5);
            if (recents.length === 0) return `<p class="desc">아직 추가된 단어가 없습니다.</p>`;

            let html = `<div class="glass-card">`;
            recents.forEach(w => {
                const langName = SUPPORTED_LANGS[getCodeByLangId(w.langId)].flag;
                html += `<div style="padding:10px; border-bottom:1px solid rgba(255,255,255,0.05); display:flex; justify-content:space-between;">
            <span>${langName} <b>${w.term}</b></span>
            <span style="opacity:0.7">${w.mean}</span>
         </div>`;
            });
            return html + `</div>`;
        }




        // --- [NEW] Analysis Features ---

        /* --- [JS 수정] 언어 분석 모달 (전체 로직 포함 + 오류 해결) --- */
        /* --- [JS 수정] openLangAnalysisModal (점수 단위 "점" 해결) --- */
        function openLangAnalysisModal(langId) {
            const lang = appData.myLangs.find(l => l.id === langId);
            const words = appData.words.filter(w => w.langId === langId);
            const groups = appData.groups.filter(g => g.langId === langId);

            // 1. 태그 통계
            const tagStats = {};
            words.forEach(w => {
                if (w.tags && w.tags.length > 0) {
                    const correct = w.stats ? (w.stats.total - w.stats.wrong) : 0;
                    const total = w.stats ? w.stats.total : 0;
                    w.tags.forEach(t => {
                        if (!tagStats[t]) tagStats[t] = { correct: 0, total: 0, count: 0 };
                        tagStats[t].correct += correct;
                        tagStats[t].total += total;
                        tagStats[t].count++;
                    });
                }
            });

            const tagList = Object.keys(tagStats).map(t => {
                const d = tagStats[t];
                const rate = d.total > 0 ? Math.round((d.correct / d.total) * 100) : 0;
                return { tag: t, rate: rate };
            }).sort((a, b) => b.rate - a.rate);

            let tagHtml = `<div class="progress-btn-container" style="margin-bottom:30px;">`;
            if (tagList.length === 0) tagHtml += `<p class="desc" style="text-align:center;">${t('no_data_graph')}</p>`;
            else {
                tagList.forEach(item => {
                    const color = item.rate < 60 ? 'var(--danger)' : 'var(--primary)';
                    tagHtml += `
            <div class="progress-btn" onclick="
                closeModal('modal-analysis');
                navigate(${langId});
                setTimeout(() => { enterSmartGroup('tag', '${item.tag}') }, 100);
            ">
                <div class="progress-bg-bar" style="width:${item.rate}%; background:${color};"></div>
                <div class="progress-content">
                    <span style="font-weight:600;">#${item.tag}</span>
                    <span class="progress-rate">${item.rate}%</span>
                </div>
            </div>`;
                });
            }
            tagHtml += `</div>`;

            // 2. 그룹 리스트
            let groupHtml = `<div class="progress-btn-container">`;
            if (groups.length === 0) groupHtml += `<p class="desc" style="text-align:center;">${t('empty_group')}</p>`;
            else {
                groups.sort((a, b) => (a.lastQuizDate || 0) - (b.lastQuizDate || 0));
                groups.forEach(g => {
                    const gWords = words.filter(w => w.groupId === g.id);
                    let totalRate = 0, ratedCnt = 0;
                    gWords.forEach(w => {
                        if (w.stats && w.stats.total > 0) {
                            totalRate += ((w.stats.total - w.stats.wrong) / w.stats.total);
                            ratedCnt++;
                        }
                    });
                    const acc = ratedCnt > 0 ? Math.round((totalRate / ratedCnt) * 100) : 0;
                    let dDay = 'New';
                    if (g.lastQuizDate) {
                        const diff = Date.now() - g.lastQuizDate;
                        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                        dDay = days === 0 ? t('today') : t('days_ago', { n: days });
                    }

                    const barWidth = acc > 0 ? acc : 0;
                    groupHtml += `
            <div class="progress-btn" onclick="closeModal('modal-analysis'); openGroupStatsModal('${g.id}');">
                <div class="progress-bg-bar" style="width:${barWidth}%; background:linear-gradient(90deg, transparent 0%, rgba(255, 100, 193, 0.8) 100%);"></div>
                <div class="progress-content">
                    <div style="display:flex; flex-direction:column; align-items:flex-start;">
                        <span style="font-size:0.95rem;">${g.title}</span>
                        <span style="font-size:0.7rem; opacity:0.7;">${dDay} • ${Math.floor(g.quizHistory?.length || 0)} ${t('exam_count')}</span>
                    </div>
                    <span class="progress-rate">${acc}%</span>
                </div>
            </div>`;
                });
            }
            groupHtml += `</div>`;

            // 3. 히스토리
            let allHistory = [];
            groups.forEach(g => {
                if (g.quizHistory && g.quizHistory.length > 0) {
                    g.quizHistory.forEach(h => {
                        allHistory.push({
                            groupId: g.id,
                            groupTitle: g.title,
                            date: h.date,
                            score: h.score,
                            wrongWords: h.wrongWords
                        });
                    });
                }
            });
            allHistory.sort((a, b) => b.date - a.date);

            let historyHtml = `<div style="display:flex; flex-direction:column;">`;
            if (allHistory.length === 0) historyHtml += `<p class="desc" style="text-align:center;">No History.</p>`;
            else {
                allHistory.slice(0, 20).forEach(h => {
                    const d = new Date(h.date);
                    const dateStr = `${d.getMonth() + 1}.${d.getDate()} ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;
                    const scoreColor = h.score >= 80 ? 'var(--primary)' : 'var(--text-dim)';

                    // [수정] 점수 뒤에 "점" 대신 번역된 suffix 사용
                    historyHtml += `
            <div class="history-item" onclick="closeModal('modal-analysis'); openGroupStatsModal('${h.groupId}', ${h.date});">
                <div style="display:flex; flex-direction:column;">
                    <span style="font-size:0.75rem; color:var(--accent); font-weight:bold;">${h.groupTitle}</span>
                    <span style="font-size:0.85rem; color:var(--text-dim); margin-top:2px;">${dateStr}</span>
                </div>
                <div style="font-size:1.1rem; font-weight:bold; color:${scoreColor};">${h.score}${t('score_suffix')}</div>
            </div>`;
                });
            }
            historyHtml += `</div>`;

            let modal = document.getElementById('modal-analysis');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'modal-analysis';
                modal.className = 'modal-overlay';
                document.body.appendChild(modal);
            }

            modal.innerHTML = `
    <div class="modal-panel">
        <div class="modal-sticky-header">
             <button onclick="closeModal('modal-analysis')" class="back-icon-btn" style="background:transparent; border:none; font-size:1.2rem;">✕</button>
             <h3 style="margin:0; font-size:1.1rem;" class="liquid-text-gradient">${SUPPORTED_LANGS[lang.code].name} Analysis</h3>
             <button onclick="navigate(${langId}); closeModal('modal-analysis');" class="back-icon-btn" style="transform: rotate(180deg);">←</button>
        </div>
        
        <div class="modal-scroll-body">
            <div style="margin-bottom:30px;">
                <h4 style="margin:0 0 10px 5px; color:var(--text-dim); font-size:0.9rem;">🔖 ${t('tags')} Analysis</h4>
                ${tagHtml}
            </div>

            <div style="margin-bottom:30px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding:0 5px;">
                     <span style="color:var(--text-dim); font-size:0.9rem; font-weight:bold;">📂 ${t('review_status')}</span>
                </div>
                ${groupHtml}
            </div>
            
            <div style="margin-bottom:20px;">
                 <h4 style="margin:0 0 10px 5px; color:var(--text-dim); font-size:0.9rem;">📝 ${t('exam_count')} History</h4>
                 ${historyHtml}
            </div>
            <div style="height:50px;"></div>
        </div>
    </div>`;

            openModalWithAnim('modal-analysis');
        }


        // [3. 모달] 그룹 통계: 그래프 클릭 시 하단에 정보 표시 (리퀴드 UI 적용)
        let currentGroupHistory = []; // 그래프 클릭 이벤트를 위해 임시 저장

        /* --- openGroupStatsModal 함수 교체 (애니메이션 수정 + 그래프 축 라벨 추가 + 라이트모드 가독성 해결) --- */
        function openGroupStatsModal(groupId, targetDate = null) {
            const group = appData.groups.find(g => String(g.id) === String(groupId));
            if (!group) return;

            // 히스토리 정렬 (날짜 오름차순)
            const history = (group.quizHistory || []).sort((a, b) => a.date - b.date);

            // 그래프 데이터 (최신 50개 제한 등은 선택사항)
            currentGroupHistory = history;

            // 초기 선택 인덱스
            let initialIndex = currentGroupHistory.length - 1;
            if (targetDate) {
                const foundIdx = currentGroupHistory.findIndex(h => h.date === targetDate);
                if (foundIdx !== -1) initialIndex = foundIdx;
            }

            // --- [그래프 설정] ---
            const pointGap = 60; // 점 사이 간격 (날짜 텍스트 공간 확보를 위해 넓힘)
            const minWidth = 340; // 화면 최소 너비
            // 데이터 개수에 맞춰 너비 계산 (좌우 패딩 40px 고려)
            const calculatedWidth = Math.max(minWidth, (currentGroupHistory.length * pointGap) + 80);

            const chartHeight = 250;
            const graphBottomY = 200; // 그래프가 그려지는 바닥 라인 (이 아래는 날짜 텍스트)
            const paddingX = 40;

            let chartHtml = '';

            if (currentGroupHistory.length < 2) {
                chartHtml = `
        <div class="glass-card" style="height:250px; display:flex; flex-direction:column; align-items:center; justify-content:center; opacity:0.6; margin:20px 0;">
            <div style="font-size:2.5rem; margin-bottom:10px;">📉</div>
            <div>${t('no_data_graph')}</div>
            <div style="font-size:0.8rem; margin-top:5px;">${t('need_more_exam')}</div>
        </div>`;
            } else {
                // 평균 점수 계산
                let sum = 0; currentGroupHistory.forEach(h => sum += h.score);
                const avg = Math.round(sum / currentGroupHistory.length);

                // 좌표 데이터 생성
                const points = currentGroupHistory.map((rec, i) => {
                    // X좌표: 순서대로 배치
                    const x = paddingX + (i * pointGap);
                    // Y좌표: 점수(0~100)를 높이(graphBottomY ~ 20)에 매핑
                    // 100점이면 y=20, 0점이면 y=200
                    const y = graphBottomY - (rec.score * ((graphBottomY - 20) / 100));
                    return { x, y, ...rec };
                });

                const pathData = points.map(p => `${p.x},${p.y}`).join(" ");
                const suffix = t('score_suffix');

                // [핵심] 라이트모드/다크모드 모두 잘 보이게 CSS 변수(var(--text-dim)) 사용
                // X축: 날짜, Y축: 점수(정답률)
                chartHtml = `
        <div class="chart-wrapper" style="overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch;">
            <div style="width: ${calculatedWidth}px; height: ${chartHeight}px;">
                <svg viewBox="0 0 ${calculatedWidth} ${chartHeight}" style="width:100%; height:100%; overflow:visible;">
                    
                    <line x1="0" y1="20" x2="${calculatedWidth}" y2="20" class="chart-axis-line" stroke-dasharray="3" />
                    <text x="5" y="15" fill="var(--text-dim)" font-size="10" font-weight="bold">100${suffix}</text>
                    
                    <line x1="0" y1="${(graphBottomY + 20) / 2}" x2="${calculatedWidth}" y2="${(graphBottomY + 20) / 2}" class="chart-axis-line" stroke-dasharray="3" />
                    <text x="5" y="${(graphBottomY + 20) / 2 - 5}" fill="var(--text-dim)" font-size="10">50${suffix}</text>
                    
                    <line x1="0" y1="${graphBottomY}" x2="${calculatedWidth}" y2="${graphBottomY}" class="chart-axis-line" />
                    <text x="5" y="${graphBottomY - 5}" fill="var(--text-dim)" font-size="10">0${suffix}</text>

                    <line x1="0" y1="${graphBottomY - (avg * ((graphBottomY - 20) / 100))}" x2="${calculatedWidth}" y2="${graphBottomY - (avg * ((graphBottomY - 20) / 100))}" 
                          stroke="var(--accent)" stroke-width="1.5" stroke-dasharray="5,3" opacity="0.5" />

                    <polyline points="${pathData}" class="chart-line-path" fill="none" />

                    ${points.map((p, idx) => {
                    const d = new Date(p.date);
                    const dateStr = `${d.getMonth() + 1}.${d.getDate()}`;
                    return `
                        <text x="${p.x}" y="${graphBottomY + 20}" fill="var(--text-dim)" font-size="10" text-anchor="middle">${dateStr}</text>
                        <circle cx="${p.x}" cy="${p.y}" r="20" fill="transparent" cursor="pointer" onclick="displayHistoryDetail(${idx})" />
                        <circle cx="${p.x}" cy="${p.y}" r="${idx === initialIndex ? 6 : 3}" 
                                class="chart-dot ${idx === initialIndex ? 'selected' : ''}" id="dot-${idx}" 
                                onclick="displayHistoryDetail(${idx})" 
                                style="fill:${idx === initialIndex ? 'var(--accent)' : 'var(--bg-main)'}; stroke:${idx === initialIndex ? '#fff' : 'var(--primary)'}; stroke-width:2px;" />
                        `;
                }).join('')}
                </svg>
            </div>
        </div>
        
        <div id="chart-detail-view" class="detail-view-container" style="min-height:100px;"></div>
        `;
            }

            let modal = document.getElementById('modal-group-stats');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'modal-group-stats';
                modal.className = 'modal-overlay';
                document.body.appendChild(modal);
            }

            modal.innerHTML = `
    <div class="modal-panel">
        <div class="modal-sticky-header">
             <button onclick="closeModal('modal-group-stats'); openLangAnalysisModal(${group.langId});" class="back-icon-btn">←</button>
             <h3 style="margin:0; font-size:1.1rem; flex:1; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${group.title}</h3>
             <button onclick="closeModal('modal-group-stats')" class="back-icon-btn" style="background:transparent; border:none;">✕</button>
        </div>

        <div class="modal-scroll-body">
            <h4 style="margin:10px 0 5px 5px; color:var(--text-dim); font-size:0.9rem;">${t('graph_title')}</h4>
            ${chartHtml}
            <div style="height:30px;"></div>
        </div>
    </div>`;

            openModalWithAnim('modal-group-stats');

            if (currentGroupHistory.length > 0) {
                setTimeout(() => {
                    displayHistoryDetail(initialIndex);
                    const wrapper = modal.querySelector('.chart-wrapper');
                    if (wrapper) {
                        wrapper.scrollLeft = (initialIndex * 60) - (wrapper.clientWidth / 2) + 40;
                    }
                }, 150);
            }
        }



        /* --- [JS 수정] displayHistoryDetail (회차/점수 번역) --- */
        function displayHistoryDetail(index) {
            const data = currentGroupHistory[index];
            const container = document.getElementById('chart-detail-view');
            if (!data || !container) return;

            document.querySelectorAll('.chart-dot').forEach(el => el.classList.remove('selected'));
            const selectedDot = document.getElementById(`dot-${index}`);
            if (selectedDot) selectedDot.classList.add('selected');

            const d = new Date(data.date);
            const dateStr = `${d.getFullYear()}.${d.getMonth() + 1}.${d.getDate()} ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;

            let wrongHtml = '';
            if (data.wrongWords && data.wrongWords.length > 0) {
                const wrongList = appData.words.filter(w => data.wrongWords.includes(w.id));
                wrongHtml = wrongList.map(w => `
            <div class="wrong-item-row">
                <div>
                    <span style="color:var(--text-main); font-weight:bold;">${w.term}</span>
                    <span style="font-size:0.8rem; color:var(--text-dim); margin-left:5px;">${w.mean}</span>
                </div>
                <button onclick="openDictWindow('${w.term}', getCodeByLangId(${w.langId}))" 
                        class="dict-btn" style="padding:4px 8px; font-size:0.7rem;">${t('dict_search')}</button>
            </div>
        `).join('');
            } else {
                wrongHtml = `<div style="text-align:center; padding:20px; color:#4CAF50; font-weight:bold;">🎉 ${t('quiz_correct1')}</div>`;
            }

            // [수정] 회차 및 점수 단위 번역 적용
            // 예: 12.26 (1회차) / (1st)
            container.innerHTML = `
        <div class="detail-card">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:1px solid var(--glass-border); padding-bottom:10px;">
                <span style="font-size:0.9rem; color:var(--text-dim);">${dateStr} (${index + 1}${t('times')})</span>
                <span style="font-size:1.2rem; font-weight:800; color:var(--primary);">${data.score}${t('score_suffix')}</span>
            </div>
            <div style="max-height:150px; overflow-y:auto;">
                ${wrongHtml}
            </div>
        </div>
    `;
        }



        /* --- [수정] renderLanguageView (UI 디자인 복구 및 정렬 수정) --- */
        function renderLanguageView(container, langId) {
            if (currentGroupId) return renderGroupDetail(container, langId, currentGroupId);
            if (currentSmartView) return renderSmartGroupDetail(container, langId);

            container.classList.remove('no-scroll');

            const myLang = appData.myLangs.find(l => l.id === langId);
            if (!myLang) return;
            const langInfo = SUPPORTED_LANGS[myLang.code];
            updateFabState('expanded');

            const fabWrapper = document.getElementById('main-fab-wrapper');
            const addBtn = document.getElementById('fab-add-btn');

            fabWrapper.style.transform = 'translateY(0)';
            fabWrapper.style.opacity = '1';

            // 언어 뷰에서는 '단어장 추가' 기능
            addBtn.onclick = () => openCreateGroupModal(langId);

            // 1. 태그 데이터 집계
            const wordsInLang = appData.words.filter(w => w.langId === langId);
            const tagCounts = {};
            wordsInLang.forEach(w => {
                if (w.tags) w.tags.forEach(t => {
                    const clean = t.trim();
                    if (clean) tagCounts[clean] = (tagCounts[clean] || 0) + 1;
                });
            });
            const sortedTags = Object.keys(tagCounts).sort((a, b) => tagCounts[b] - tagCounts[a]);

            // 2. 스마트 그룹 HTML 생성 (디자인 복구: smart-card-inner 사용)
            // 인라인 스타일(flex 등)을 제거하고 CSS 클래스에 위임하여 정렬 문제 해결
            let smartWidgetsHTML = `
        <div class="glass-card stat-widget" onclick="enterSmartGroup('wrong_last', null)" style="cursor:pointer; padding:15px; aspect-ratio:1/1;">
             <div class="smart-card-inner">
                <div style="font-size:2rem; margin-bottom:10px;">💊</div>
                <div class="stat-label" style="font-size:0.9rem; word-break:keep-all;">${t('smart_last_wrong')}</div>
             </div>
        </div>
        <div class="glass-card stat-widget" onclick="enterSmartGroup('wrong_freq', null)" style="cursor:pointer; padding:15px; aspect-ratio:1/1;">
             <div class="smart-card-inner">
                <div style="font-size:2rem; margin-bottom:10px;">🔥</div>
                <div class="stat-label" style="font-size:0.9rem; word-break:keep-all;">${t('smart_freq_wrong')}</div>
             </div>
        </div>
    `;

            sortedTags.forEach(tag => {
                smartWidgetsHTML += `
        <div class="glass-card stat-widget" onclick="enterSmartGroup('tag', '${tag}')" style="cursor:pointer; padding:15px; aspect-ratio:1/1; border:1px solid var(--glass-border);">
             <div class="smart-card-inner">
                <div style="font-size:1.8rem; color:var(--text-main); margin-bottom:8px; font-weight:300;">#</div>
                <div style="font-weight:bold; font-size:1.1rem; color:var(--text-main); margin-bottom:2px;">${tag}</div>
                <div style="font-size:0.8rem; opacity:0.6;">(${tagCounts[tag]})</div>
             </div>
        </div>`;
            });

            const totalItems = 2 + sortedTags.length;
            const manageBtnText = isGroupManageMode ? t('done') : t('manage');
            const manageBtnClass = isGroupManageMode ? "manage-btn active" : "manage-btn";
            const logoSrc = getLogoSrc();

            // 3. 전체 HTML 렌더링
            container.innerHTML = `
        <header style="margin-top:10px; margin-bottom:20px; padding:0 10px; text-align:center;">
            <div class="logo-container"><img src="${logoSrc}" class="app-logo" id="logo-main" alt="PrismV Logo"></div>
            <div style="text-align:left;">
                <div style="font-size:0.9rem; color:var(--text-dim); margin-bottom:5px;">${t('language')}</div>
                <h1 style="margin:0; font-size:1.8rem;">${langInfo.flag} ${langInfo.name}</h1>
            </div>
        </header>

        <h3 style="margin: 30px 0 10px 10px; color:var(--accent);">${t('smart_group')}</h3>
        
        <div class="smart-group-container">
            <!-- data-total 속성으로 총 개수 전달 -->
            <div id="smart-grid" class="smart-group-grid" data-total="${totalItems}">
                 ${smartWidgetsHTML}
            </div>
            <button id="btn-smart-expand" class="expand-btn" onclick="toggleSmartGrid()">▼ ${t('show_all')}</button>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; margin: 40px 10px 10px 10px;">
            <h3 style="margin:0; color:var(--text-main);">${t('my_vocas')}</h3>
            <button onclick="toggleGroupManageMode(${langId})" class="${manageBtnClass}">${manageBtnText}</button>
        </div>
        
        <div id="group-list-area" class="my-vocab-list">
             ${renderGroupListNew(langId)}
        </div>
    `;

            // 탭 전환 시에는 접힌 상태로 초기화
            isSmartGridExpanded = false;

            // UI 상태 업데이트 (높이 계산 등)
            setTimeout(updateSmartGridUI, 50);

            // 리사이즈 이벤트 재등록
            window.removeEventListener('resize', updateSmartGridUI);
            window.addEventListener('resize', updateSmartGridUI);
        }




        /* --- [핵심 수정] Max-Height 애니메이션 기반 계산 함수 --- */
        function updateSmartGridUI() {
            const grid = document.getElementById('smart-grid');
            const btn = document.getElementById('btn-smart-expand');
            if (!grid || !btn) return;

            const items = Array.from(grid.children);
            const total = items.length;

            // 아이템이 없으면 종료
            if (total === 0) {
                btn.style.display = 'none';
                return;
            }

            // 1. 현재 열(Column) 개수 및 카드 높이 계산
            // 정확한 계산을 위해 첫 번째 아이템의 위치와 크기 참조
            const firstItem = items[0];
            const itemHeight = firstItem.offsetHeight; // 카드 높이
            const itemTop = firstItem.offsetTop;

            // 같은 행(offsetTop이 같은)에 있는 아이템 개수 = 열 개수
            let columns = items.filter(item => item.offsetTop === itemTop).length;
            if (columns < 1) columns = 1; // 안전장치

            // 2. 제한할 행(Row) 개수 설정
            const width = window.innerWidth;
            let maxRows = 3; // PC 기본
            if (width <= 600) maxRows = 5;      // 모바일 5행
            else if (width <= 900) maxRows = 4; // 태블릿 4행

            const limitCount = columns * maxRows; // 보여줄 총 개수

            // 3. 높이 계산 및 애니메이션 적용
            const gap = 12; // CSS gap: 12px

            if (total <= limitCount) {
                // 숨길 게 없으면 버튼 숨기고 높이 제한 해제
                btn.style.display = 'none';
                grid.style.maxHeight = 'none';
            } else {
                // 숨길 게 있으면 버튼 표시
                btn.style.display = 'block';

                if (isSmartGridExpanded) {
                    // 펼침 상태: 전체 높이 (scrollHeight)
                    grid.style.maxHeight = grid.scrollHeight + "px";
                    btn.innerText = `▲ ${t('fold')} (${total})`;
                } else {
                    // 접힘 상태: (카드높이 * 행수) + (간격 * (행수-1))
                    // 계산된 높이만큼만 max-height 설정 -> 넘치는 건 CSS overflow:hidden으로 잘림
                    const collapsedHeight = (itemHeight * maxRows) + (gap * (maxRows - 1)) + 30;
                    grid.style.maxHeight = collapsedHeight + "px";
                    btn.innerText = `▼ ${t('show_all')} (${total})`;
                }
            }
        }

        /* --- [수정] 토글 함수 --- */
        function toggleSmartGrid() {
            isSmartGridExpanded = !isSmartGridExpanded;
            updateSmartGridUI();
        }

        // --- [JS 추가] 2. enterSmartGroup 함수 정의 (누락 방지) ---
        // 이 함수가 없어서 ReferenceError가 발생했습니다. 명시적으로 추가합니다.
        function enterSmartGroup(mode, value) {
            currentSmartView = { mode, value };

            // [수정] 스마트 그룹 진입 (Level 2)
            history.pushState({ level: 2, view: 'smart', data: { mode, value } }, null, '');

            renderApp();
        }



        /* [수정] renderGroupDetail: 필터 및 별표 기능 적용 */
        function renderGroupDetail(container, langId, groupId) {
            container.classList.add('no-scroll');

            // ... (기존 FAB 및 버튼 초기화 코드는 그대로 유지) ...
            const fabWrapper = document.getElementById('main-fab-wrapper');
            updateFabState('expanded');
            const addBtn = document.getElementById('fab-add-btn');
            fabWrapper.style.transform = 'translateY(0)';
            fabWrapper.style.opacity = '1';
            addBtn.onclick = () => openAddWordModal();

            const group = appData.groups.find(g => g.id === groupId);
            if (!group) return;

            let wordsInGroup = appData.words.filter(w => w.groupId === groupId);

            // [수정 1] 필터링 적용 (화면 표시용 displayList만 필터링)
            let displayList = [...wordsInGroup];

            if (currentWordFilter === 'fav') {
                displayList = displayList.filter(w => w.isFav);
            } else if (currentWordFilter === 'weak') {
                displayList = displayList.filter(w => (w.stats?.wrong || 0) >= 3);
            } else if (currentWordFilter === 'wrong_last') {
                displayList = displayList.filter(w => w.stats?.lastResult === 'wrong');
            }

            // ... (기존 통계 계산 변수들, dateCreated 등은 그대로 유지) ...
            const langInfo = SUPPORTED_LANGS[getCodeByLangId(langId)];
            // 통계는 전체 단어 기준이어야 정확하므로 wordsInGroup 사용
            let stats = { total: wordsInGroup.length, tries: 0, wrong: 0, acc: 0 };
            if (wordsInGroup.length > 0) { /* ...기존 통계 계산 로직 유지... */
                // (여기에 기존 통계 코드 그대로)
                const triesArr = wordsInGroup.map(w => w.stats ? w.stats.total : 0);
                stats.tries = Math.min(...triesArr);
                let sT = 0, sW = 0;
                wordsInGroup.forEach(w => {
                    if (w.stats) { sT += w.stats.total; if ((w.stats.wrong || 0) >= 3) stats.wrong++; sW += w.stats.wrong || 0; }
                });
                if (sT > 0) stats.acc = Math.round(((sT - sW) / sT) * 100);
            }

            const fmtDate = (ts) => { if (!ts) return '-'; const d = new Date(ts); return `${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}`; };
            const dateCreated = fmtDate(group.createdAt);
            const dateQuiz = group.lastQuizDate ? fmtDate(group.lastQuizDate) : '-';
            const dateMod = group.modifiedAt ? fmtDate(group.modifiedAt) : dateCreated;
            const manageBtnText = isManageMode ? t('done') : t('manage');
            const manageBtnClass = isManageMode ? "manage-btn active" : "manage-btn";

            // Play All 버튼은 전체 리스트 대상
            let startBtnHTML = '';
            if (wordsInGroup.length > 0 && !isManageMode) {
                startBtnHTML = `<button onclick="startQuizFromIndex('${groupId}', 0)" class="play-all-btn">▶ Play All</button>`;
            }

            // --- HTML 생성 시작 ---
            let html = `
    <div id="sticky-header" class="fixed-header-layer">
        <div class="header-card-inner layout-container">
            <div class="top-row" style="margin-bottom:10px;">
                <button onclick="history.back()" class="back-icon-btn">←</button>
                <div class="header-title-area" style="text-align:left;">
                     <div class="header-subtitle" style="font-size:0.8rem; color:var(--accent);">${langInfo.name} | ${dateCreated}</div>
                     <div class="main-title" style="font-size:1.4rem;">
                        ${group.title} <button class="title-edit-btn" onclick="editGroupTitle('${groupId}')">✎</button>
                     </div>
                </div>
                ${startBtnHTML}
            </div>

             <!-- [추가] 헤더 내에 고정된 필터/관리 툴바 (리퀴드 스타일) -->
            <div class="glass-toolbar" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding: 10px; background:rgba(255,255,255,0.05); border-radius:12px; border:1px solid var(--glass-border); backdrop-filter:blur(5px);">
                <div class="filter-group">
                    <button class="filter-icon-btn btn-fav ${currentWordFilter === 'fav' ? 'active' : ''}" 
                            onclick="setWordFilter('fav')">★</button>
                    
                    <button class="filter-icon-btn ${currentWordFilter === 'weak' ? 'active' : ''}" 
                            onclick="setWordFilter('weak')">${t('filter_weak')}</button>
                    
                    <button class="filter-icon-btn ${currentWordFilter === 'wrong_last' ? 'active' : ''}" 
                            onclick="setWordFilter('wrong_last')">${t('filter_last')}</button>
                </div>
                <button onclick="toggleManageMode()" class="${manageBtnClass}" style="flex-shrink:0;">${manageBtnText}</button>
            </div>
            
            <!-- (통계 패널 HTML 기존 유지) -->
            <div class="stats-wrapper" style="margin-bottom:0;">
                <div class="stats-dashboard" style="border-bottom-left-radius:0; border-bottom-right-radius:0; border-bottom:none;">
                    <div class="stat-item"><span class="stat-label">${t('total_words')}</span><span class="stat-value" style="font-size:1.2rem;">${stats.total}</span></div>
                    <div class="stat-item"><span class="stat-label">${t('exam_count')}</span><span class="stat-value" style="font-size:1.2rem; color:var(--text-main);">${stats.tries}</span></div>
                    <div class="stat-item"><span class="stat-label">${t('accuracy')}</span><span class="stat-value" style="font-size:1.2rem; color:#4CAF50;">${stats.acc}%</span></div>
                    <div class="stat-item"><span class="stat-label">${t('stat_weak')}</span><span class="stat-value" style="font-size:1.2rem; color:var(--danger);">${stats.wrong}</span></div>
                </div>
                <div style="display:flex; justify-content:space-around; align-items:center; background:rgba(0,0,0,0.03); border:1px solid var(--glass-border); border-top:none; border-radius:0 0 12px 12px; padding:8px 5px;">
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <span style="font-size:0.75rem; opacity:0.6; margin-bottom:2px;">📝 ${t('recent_quiz')}</span> 
                        <span style="color:var(--text-main); font-weight:600; font-size:0.9rem;">${dateQuiz}</span>
                    </div>
                    <div style="width:1px; height:20px; background:var(--glass-border);"></div>
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <span style="font-size:0.75rem; opacity:0.6; margin-bottom:2px;">✍️ ${t('recent_mod')}</span> 
                        <span style="color:var(--text-main); font-weight:600; font-size:0.9rem;">${dateMod}</span>
                    </div>
                </div>
                <button onclick="openGroupStatsModal('${groupId}')" 
                        style="width:100%; margin-top:0; padding:10px; background:var(--glass-bg); border:1px solid var(--glass-border); border-top:none; border-radius:0 0 12px 12px; color:var(--text-main); font-size:0.9rem; font-weight:600; cursor:pointer;">
                    ${t('click_analyze')}
                </button>
            </div>
        </div>
    </div>

    <div id="scroll-area" class="scroll-content-area">
        <div id="header-spacer" style="width:100%; height:340px;"></div> 

        <div id="word-items-list" class="layout-container" style="padding-bottom:100px;">
            
            
    `;

            if (displayList.length === 0) {
                html += `<p style="text-align:center; padding:50px; opacity:0.5;">${t('no_matching_word')}</p>`;
            } else {
                const itemClass = isManageMode ? "managing" : "";

                displayList.forEach((w, idx) => {
                    const ttsCode = getCodeByLangId(langId);
                    const ttsText = ((ttsCode === 'ja' || ttsCode === 'zh') && w.pron) ? w.pron : w.term;

                    const listNum = idx + 1;
                    const isFavClass = w.isFav ? 'active' : '';

                    /* [수정] HTML 구조 재정립 (div 닫힘 확인 필수) */
                    html += `
             <div class="word-item ${itemClass}" id="${w.id}" data-index="${idx}" data-type="word" 
                  ondragover="dragOver(event)" ondrop="dropItem(event)"
                  style="border-radius:15px; margin-bottom:10px; border:1px solid var(--glass-border); display:flex; align-items:center; padding: 15px; position: relative;">
                 
                 <!-- 좌측 영역: 별표/순번 또는 드래그 핸들 -->
                 <!-- .item-left-col 클래스 사용 (CSS로 제어됨) -->
                 <div class="item-left-col">
                    ${isManageMode
                            ? `<div class="drag-handle" 
                                    draggable="true" 
                                    ondragstart="dragStart(event)" 
                                    ontouchstart="touchStart(event)" 
                                    ontouchmove="touchMove(event)" 
                                    ontouchend="touchEnd(event)">≡</div>`
                            : `<div class="star-index-wrapper ${isFavClass}" id="star-btn-${w.id}" onclick="toggleFavorite(${w.id}, event)">
                                   <img src="./Asset/favorite.svg" class="star-icon-img" alt="fav">
                                   <span class="star-number">${listNum}</span>
                               </div>`
                        }
                 </div>

                 <!-- 단어 텍스트 영역 -->
                 <div class="word-content" onclick="openWordDetail(${w.id})" style="flex:1; min-width:0; cursor:pointer;">
                     <div class="word-row-main" style="color:var(--text-main); font-weight:600; font-size:1.15rem; line-height:1.2; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        ${w.term} <span class="word-pron" style="font-weight:normal; color:var(--accent); font-size:0.85rem; margin-left:5px;">${w.pron || ''}</span>
                     </div>
                     <div class="word-row-sub" style="opacity:0.8; margin-top:2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${w.mean}</div>
                 </div>
                 
                 <!-- 우측 버튼 영역 -->
                 <div class="icon-actions" style="display:flex; align-items:center; gap:8px; flex-shrink:0;">
                    ${isManageMode
                            ? `<button class="btn-icon-text" style="font-size:1.2rem; padding:5px;" onclick="editWord(${w.id})">✎</button>
                               <button class="delete-btn-x" onclick="deleteWord(${w.id})">✕</button>`
                            : `
                               <button class="icon-btn play-sound" onclick="speak('${ttsText}','${ttsCode}')">🔊</button>
                               <button class="dict-btn" onclick="openDictWindow('${w.term}','${ttsCode}')">${t('dict_search')}</button>
                               <button class="quiz-start-btn" onclick="startQuizFromIndex('${groupId}', ${idx})" title="${t('quiz_start_idx')}">▶</button>`
                        }
                 </div>
             </div>`;
                });
            }

            html += `</div></div>`;
            container.innerHTML = html;

            setTimeout(() => {
                const hCard = document.querySelector('.header-card-inner');
                if (hCard) document.getElementById('header-spacer').style.height = (hCard.offsetHeight + 20) + 'px';
            }, 50);

            const scrollEl = document.getElementById('scroll-area');
            const headerLayer = document.getElementById('sticky-header');
            if (scrollEl && headerLayer) {
                scrollEl.onscroll = () => {
                    if (scrollEl.scrollTop > 30) headerLayer.classList.add('shrunk');
                    else headerLayer.classList.remove('shrunk');
                };
            }
        }



        /* --- [JS 수정] renderGroupListNew (다국어 적용) --- */
        function renderGroupListNew(langId) {
            let groups = appData.groups.filter(g => g.langId === langId);

            if (groups.length === 0) return `<p class="desc" style="text-align:center; margin-top:20px;">${t('empty_group')}</p>`;

            let html = '';
            groups.forEach((g, idx) => {
                const count = appData.words.filter(w => w.groupId === g.id).length;
                const d = new Date(g.createdAt);
                const dateStr = `${d.getMonth() + 1}.${d.getDate()}`;

                let dDayHtml = '';
                if (g.lastQuizDate && !isGroupManageMode) {
                    const diff = Date.now() - g.lastQuizDate;
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));

                    let text = "";
                    let color = "var(--text-dim)";

                    if (days === 0) {
                        text = `${t('today')} ${t('review_status')}`;
                        color = "#4CAF50";
                    } else {
                        text = `${t('days_ago', { n: days })} ${t('review_status')}`;
                        if (days >= 7) color = "var(--accent)";
                        if (days >= 30) color = "var(--danger)";
                    }

                    dDayHtml = `<span style="font-size:0.8rem; color:${color}; font-weight:600; margin-right:5px;">${text}</span>`;
                }

                const cursorStyle = isGroupManageMode ? "default" : "pointer";

                html += `
        <div class="glass-card vocab-card" 
             style="margin-bottom:12px; cursor:${cursorStyle}; display:flex; align-items:center; padding: 15px;"
             onclick="${isGroupManageMode ? '' : `enterGroup('${g.id}')`}"
             data-index="${idx}" data-type="group"
             ondragover="dragOver(event)" ondrop="dropItem(event)">
             
             ${isGroupManageMode
                        ? `<div class="drag-handle" 
                                style="margin-right:15px; padding:10px;" 
                                draggable="true" 
                                ondragstart="dragStart(event)" 
                                ontouchstart="touchStart(event)" 
                                ontouchmove="touchMove(event)" 
                                ontouchend="touchEnd(event)">≡</div>`
                        : ``
                    }

             <div style="flex:1;">
                <div style="font-size:1.1rem; font-weight:bold; margin-bottom:4px;">${g.title}</div>
                <div style="font-size:0.85rem; color:var(--text-dim);">
                    <span>${dateStr}</span> • <span style="color:var(--primary);">${count} ${t('total_words')}</span>
                </div>
             </div>

             <div style="display:flex; align-items:center; gap:10px;">
                ${isGroupManageMode
                        ? `<button class="btn-icon-text" style="font-size:1rem;" onclick="editGroup('${g.id}')">✎</button>
                       <button class="delete-btn-x" onclick="deleteGroup('${g.id}')">✕</button>`
                        : `${dDayHtml}<div style="color:var(--accent); font-size:1.5rem; opacity:0.5;">›</div>`
                    }
             </div>
        </div>`;
            });
            return html;
        }

        // [JS 추가] 그룹 생성 모달 열기
        let tempCreateLangId = null;

        /* --- [JS 수정] 단어장 생성 모달 (다국어 렌더링 적용) --- */
        function openCreateGroupModal(langId) {
            if (!langId) {
                if (typeof currentTab === 'number') langId = currentTab;
                else return alert("Please select a language.");
            }
            tempCreateLangId = langId;

            const today = new Date();
            const defaultTitle = `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()} ${t('review_status')}`;

            const modalPanel = document.querySelector('#modal-create-group .modal-panel');

            modalPanel.innerHTML = `
        <div class="modal-sticky-header">
            <button onclick="closeModal('modal-create-group')" class="back-icon-btn" style="border:none; background:none;">✕</button>
            <h3 style="margin:0; font-size:1.1rem;">${t('new_group_title')}</h3>
            <div style="width:40px;"></div>
        </div>

        <div class="modal-scroll-body">
            <div style="text-align:center; margin: 10px 0 30px 0;">
                <div style="font-size:3rem; margin-bottom:10px;">📁</div>
                <p class="desc" style="margin:0;">${t('new_group_desc')}</p>
            </div>

            <div class="glass-card" style="padding:20px; margin-bottom:20px;">
                <div class="input-group">
                    <span class="input-label" style="margin-left:2px;">${t('grp_name')}</span>
                    <input type="text" id="inp-group-title" placeholder="${defaultTitle}" style="margin-bottom:15px;">
                </div>

                <div class="input-group" style="margin-bottom:0;">
                    <span class="input-label" style="margin-left:2px;">${t('grp_desc')}</span>
                    <input type="text" id="inp-group-desc" placeholder="Day 1" style="margin-bottom:0;">
                </div>
            </div>

            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="glass-btn primary" onclick="submitCreateGroup()" style="height:50px; font-size:1rem;">${t('create')}</button>
                <button class="glass-btn" onclick="closeModal('modal-create-group')" style="height:50px;">${t('cancel')}</button>
            </div>
            <div class="modal-footer-gap"></div>
        </div>
    `;

            openModalWithAnim('modal-create-group');
            setTimeout(() => {
                const inp = document.getElementById('inp-group-title');
                if (inp) inp.focus();
            }, 150);
        }

        function submitCreateGroup() {
            if (!tempCreateLangId) return;

            const input = document.getElementById('inp-group-title');
            const inputDesc = document.getElementById('inp-group-desc'); // [추가]

            let title = input.value.trim();
            let desc = inputDesc ? inputDesc.value.trim() : ''; // [추가] 설명 가져오기

            if (!title) {
                title = input.placeholder;
            }

            const newGroup = {
                id: Date.now().toString(),
                langId: tempCreateLangId,
                title: title,
                description: desc, // [추가] 데이터에 저장
                type: 'custom',
                createdAt: Date.now()
            };

            appData.groups.push(newGroup);
            saveData();
            closeModal('modal-create-group');

            renderLanguageView(document.getElementById('main-view-area'), tempCreateLangId);
        }


        // [오류 해결] 상세 화면 헤더용 제목 수정 함수 추가
        function editGroupTitle(groupId) {
            // ID 타입을 문자로 통일하여 안전하게 찾기
            const group = appData.groups.find(g => String(g.id) === String(groupId));
            if (!group) return;

            // 이름 입력받기 (기본값: 현재 제목)
            const newTitle = prompt("단어장 이름을 수정하세요:", group.title);

            // 취소하지 않고 내용이 있을 때만 저장
            if (newTitle && newTitle.trim() !== "") {
                group.title = newTitle.trim();
                group.modifiedAt = Date.now(); // 수정된 날짜도 갱신

                saveData();  // 저장
                renderApp(); // 화면 갱신 (제목 변경 반영)
            }
        }

        // [신규] 그룹 이름 변경 (Prompt 사용, 단순 구현)
        function editGroup(groupId) {
            const group = appData.groups.find(g => g.id === groupId);
            if (!group) return;

            // 현재 이름(또는 날짜)을 default value로 보여줌
            const newTitle = prompt(t('edit_group'), group.title);
            if (newTitle && newTitle.trim() !== "") {
                group.title = newTitle;
                saveData();
                renderApp();
            }
        }

        // [신규] 그룹 삭제
        function deleteGroup(groupId) {
            if (!confirm(t('delete_confirm'))) return;

            // 그룹 내 단어 모두 삭제 (필요 시 유지하려면 로직 변경)
            appData.words = appData.words.filter(w => w.groupId !== groupId);
            // 그룹 삭제
            appData.groups = appData.groups.filter(g => g.id !== groupId);

            saveData();
            renderApp();
        }

        function addGroup(langId, type) {
            const title = type === 'date' ?
                new Date().toLocaleDateString() + " 학습" :
                prompt("새 단어장 이름 입력:");

            if (!title) return;

            appData.groups.push({
                id: Date.now().toString(),
                langId: langId,
                title: title,
                type: type, // 'date', 'list'
                createdAt: Date.now()
            });
            saveData();
            renderMainContent(); // refresh
        }

        /* --- [수정] enterGroup 함수 (ID 변경 반영) --- */
        function enterGroup(groupId) {
            if (isGroupManageMode) return;

            currentGroupId = groupId;

            // [오류 해결] 기존 'main-fab'은 삭제되었으므로, 새로운 'main-fab-wrapper'를 제어해야 함
            const fabWrapper = document.getElementById('main-fab-wrapper');
            if (fabWrapper) {
                fabWrapper.style.transform = 'translateY(0)';
                fabWrapper.style.opacity = '1';
            }
            updateFabState('expanded');
            // [수정] 그룹 진입 (Level 2) 히스토리 추가
            history.pushState({ level: 2, view: 'group', groupId: groupId }, null, '');

            renderApp();
        }

        // 3. Group Detail View (단어 추가 및 목록)
        // --- [Global State 추가] 관리 모드 상태 변수 ---
        let isManageMode = false;





        // [JS 추가] 그룹 관리 모드 토글
        function toggleGroupManageMode(langId) {
            isGroupManageMode = !isGroupManageMode;
            const container = document.getElementById('main-view-area');
            // 화면만 갱신 (리렌더링)
            renderLanguageView(container, langId);
        }

        // [JS 추가] 그룹 순서 변경
        function moveGroup(groupId, direction) {
            // 1. 현재 언어 ID 찾기
            const targetGroup = appData.groups.find(g => g.id === groupId);
            if (!targetGroup) return;
            const currentLangId = targetGroup.langId;

            // 2. 전체 groups 배열에서 인덱스 찾기
            const idx = appData.groups.findIndex(g => g.id === groupId);
            if (idx === -1) return;

            // 3. 이동할 대상 인덱스 계산 (위로가면 -1, 아래로가면 +1)
            const targetIdx = idx + direction;

            // 4. 범위 체크 및 같은 언어 그룹끼리만 이동
            if (targetIdx < 0 || targetIdx >= appData.groups.length) return;

            // 단순히 배열에서만 바꾸면 다른 언어 그룹과 섞일 수 있으므로
            // "화면에 보이는 리스트" 상에서의 이동이 아니라 실제 데이터 배열에서의 이동을 처리해야 함.
            // 하지만 단순화를 위해 바로 옆 데이터와 스왑하되, 
            // UX적으로는 필터링된 뷰에서 움직이는 걸 기대하므로
            // 실제로는 전체 배열에서 `swap`을 수행합니다.

            // 데이터 스왑
            const temp = appData.groups[idx];
            appData.groups[idx] = appData.groups[targetIdx];
            appData.groups[targetIdx] = temp;

            saveData();
            // 화면 갱신
            renderLanguageView(document.getElementById('main-view-area'), currentLangId);
        }




        // --- [Group Detail] Actions ---

        function exitGroup() {
            history.back();
        }

        function toggleManageMode() {
            isManageMode = !isManageMode;
            // 관리 모드 진입 시, 필터를 '전체(all)'로 강제하여 드래그 순서 오류 방지
            if (isManageMode) {
                currentWordFilter = 'all';
            }
            renderApp();
        }

        // [핵심] 단어 순서 이동 (Swap Logic)
        function moveWord(wordId, direction) {
            // wordId는 숫자일수도 문자일수도 있으니 매칭 주의
            const wordIdNum = Number(wordId);

            // 전체 word 리스트에서 이 그룹의 단어들 인덱스를 찾음
            // 우리는 화면에 '역순(최신이 위)'으로 보여주지만,
            // 데이터 저장은 '정순(추가된 순서)'으로 되어 있음.
            // 
            // 화면상에서 [위로] 버튼 = 최신(배열 뒤쪽)에서 더 최신(더 뒤쪽)으로 이동? 
            // 헷갈리므로 -> "화면에 보이는 순서"를 기준으로 잡음.
            // 화면: [Word C, Word B, Word A] (인덱스: 2, 1, 0)
            // Word B를 '위로(-1)' 보냄 -> [Word B, Word C, Word A] 가 되어야 함.
            // 이는 실제 배열 [A, B, C] 에서 B(1)와 C(2)를 바꾸는 것.
            // 즉, 화면상 '위(-1)'는 실제 배열 인덱스 '+1' 방향(뒤쪽)과 연관됨 (역순 표시니까).

            // 하지만 가장 직관적인건 그냥 '배열 인덱스'를 바꾸는 것.
            // 단순히 appData.words 배열 내에서 해당 아이템을 앞/뒤 요소와 swap 하면 됨.
            // 문제는 appData.words에는 다른 그룹 단어도 섞여 있다는 점.

            const allIndex = appData.words.findIndex(w => w.id === wordIdNum);
            if (allIndex === -1) return;

            // 현재 그룹의 단어들만 추출하여 그 안에서의 상대적 위치 확인
            const groupWords = appData.words.filter(w => w.groupId === currentGroupId);
            // groupWords 내부에서의 인덱스 찾기
            const localIndex = groupWords.findIndex(w => w.id === wordIdNum);

            // 목표 위치 계산 (화면상 역순이므로 방향 반대)
            // 화면 [위로] = localIndex + 1 (나보다 나중에 들어온 놈이랑 자리 바꿈)
            // 화면 [아래로] = localIndex - 1 (나보다 먼저 들어온 놈이랑 자리 바꿈)
            // 
            // 왜? 화면엔 [3, 2, 1, 0] 순서로 찍힘. 2번을 위로 보내면 [2, 3, 1, 0]이 됨.
            // 실제 배열은 [0, 1, 2, 3] 이므로, 2번이 3번 자리로 가야 함 (index + 1)

            const targetLocalIndex = localIndex + (direction === -1 ? 1 : -1);

            if (targetLocalIndex < 0 || targetLocalIndex >= groupWords.length) return; // 이동 불가

            const targetWord = groupWords[targetLocalIndex];
            const targetAllIndex = appData.words.findIndex(w => w.id === targetWord.id);

            // 실제 배열(Global)에서 두 아이템 Swap
            const temp = appData.words[allIndex];
            appData.words[allIndex] = appData.words[targetAllIndex];
            appData.words[targetAllIndex] = temp;

            saveData();
            renderApp();
        }




        // [신규] 사전 팝업 헬퍼
        function openDictWindow(term, code) {
            const langInfo = SUPPORTED_LANGS[code];
            const url = langInfo.url + encodeURIComponent(term);
            window.open(url, '_blank', 'width=450,height=600');
        }

        // [JS 수정] 스마트 그룹에서도 개별 퀴즈 시작 버튼(▶) 추가
        /* --- [JS 수정] renderSmartGroupDetail (번역 누락 해결) --- */
        function renderSmartGroupDetail(container, langId) {
            container.classList.add('no-scroll');

            updateFabState('home');
            const fabWrapper = document.getElementById('main-fab-wrapper');
            if (fabWrapper) {
                fabWrapper.style.transform = 'translateY(100px)';
                fabWrapper.style.opacity = '0';
            };

            const { mode, value } = currentSmartView;
            const langInfo = SUPPORTED_LANGS[getCodeByLangId(langId)];

            let filteredWords = [];
            let title = "";

            if (mode === 'tag') {
                title = `#${value}`;
                filteredWords = appData.words.filter(w => w.langId === langId && w.tags?.includes(value));
            } else if (mode === 'wrong_last') {
                title = t('smart_last_wrong'); // 번역
                filteredWords = appData.words.filter(w => w.langId === langId && w.stats?.lastResult === 'wrong');
            } else if (mode === 'wrong_freq') {
                title = t('smart_freq_wrong'); // 번역
                filteredWords = appData.words.filter(w => w.langId === langId && (w.stats?.wrong || 0) >= 3);
            }

            const displayList = [...filteredWords].reverse();

            let stats = { total: displayList.length, tries: 0, wrong: 0, acc: 0 };
            if (displayList.length > 0) {
                let sT = 0, sW = 0;
                const triesArr = displayList.map(w => w.stats ? w.stats.total : 0);
                stats.tries = Math.min(...triesArr);

                displayList.forEach(w => {
                    if (w.stats) {
                        sT += w.stats.total;
                        if ((w.stats.wrong || 0) >= 3) stats.wrong++;
                        sW += w.stats.wrong || 0;
                    }
                });
                if (sT > 0) stats.acc = Math.round(((sT - sW) / sT) * 100);
            }
            const todayStr = new Date().toLocaleDateString();

            let startBtnHTML = '';
            if (displayList.length > 0) {
                startBtnHTML = `<button onclick="startQuizFromSmartGroup(0)" class="play-all-btn">▶ Play All</button>`;
            }

            let html = `
    <div id="sticky-header" class="fixed-header-layer">
        <div class="header-card-inner layout-container">
            <div class="top-row" style="margin-bottom:10px;">
                <button onclick="currentSmartView=null; renderApp()" class="back-icon-btn">←</button>
                <div class="header-title-area" style="text-align:left;">
                     <div class="header-subtitle" style="font-size:0.8rem; color:var(--accent);">${langInfo.name} | ${todayStr}</div>
                     <div class="main-title" style="font-size:1.4rem;">${title}</div>
                </div>
                ${startBtnHTML}
            </div>

            <div class="stats-wrapper">
                <div class="stats-dashboard">
                    <!-- [수정] 통계 라벨 번역 적용 -->
                    <div class="stat-item"><span class="stat-label">${t('total_words')}</span><span class="stat-value" style="font-size:1.2rem;">${stats.total}</span></div>
                    <div class="stat-item"><span class="stat-label">${t('stat_min_try')}</span><span class="stat-value" style="font-size:1.2rem; color:var(--text-main);">${stats.tries}</span></div>
                    <div class="stat-item"><span class="stat-label">${t('stat_avg_acc')}</span><span class="stat-value" style="font-size:1.2rem; color:#4CAF50;">${stats.acc}%</span></div>
                    <div class="stat-item"><span class="stat-label">${t('stat_weak')}</span><span class="stat-value" style="font-size:1.2rem; color:var(--danger);">${stats.wrong}</span></div>
                </div>
            </div>
        </div>
    </div>

    <div id="scroll-area" class="scroll-content-area">
        <div id="header-spacer" style="width:100%; height:260px;"></div> 

        <div id="word-items-list" class="layout-container" style="padding-bottom:100px;">
    `;

            if (displayList.length === 0) {
                // [수정] 안내 메시지 번역 적용
                html += `<p style="text-align:center; padding:50px; opacity:0.5;">${t('no_matching_word')}</p>`;
            } else {
                displayList.forEach((w, idx) => {
                    const ttsCode = getCodeByLangId(langId);
                    const ttsText = ((ttsCode === 'ja' || ttsCode === 'zh') && w.pron) ? w.pron : w.term;
                    const listNum = idx + 1;

                    html += `
             <div class="word-item" style="border-radius:15px; margin-bottom:10px; border:1px solid var(--glass-border); display:flex; align-items:center; padding: 15px;">
                 <div style="width:15px; flex-shrink:0; display:flex; align-items:center; justify-content:center;">
                    <div class="item-number" style="font-size:1rem; color:var(--text-dim);">${listNum}</div>
                 </div>

                 <div class="word-content" onclick="openWordDetail(${w.id})" style="flex:1; margin-left:5px; cursor:pointer;">
                     <div class="word-row-main" style="color:var(--text-main); font-weight:600; line-height:1.2;">
                        ${w.term} <span class="word-pron" style="font-weight:normal; color:var(--accent); margin-left:5px;">${w.pron || ''}</span>
                     </div>
                     <div class="word-row-sub" style="opacity:0.8; margin-top:2px;">${w.mean}</div>
                 </div>
                 
                 <div class="icon-actions" style="display:flex; gap:10px;">
                    <button class="icon-btn play-sound" onclick="speak('${ttsText}','${ttsCode}')">🔊</button>
                    <button class="dict-btn" onclick="openDictWindow('${w.term}','${ttsCode}')">${t('dict_search')}</button>
                    <button class="quiz-start-btn" onclick="startQuizFromSmartGroup(${idx})" title="${t('quiz_start_idx')}">▶</button>
                 </div>
             </div>`;
                });
            }

            html += `</div></div>`;
            container.innerHTML = html;

            setTimeout(() => {
                const hCard = document.querySelector('.header-card-inner');
                if (hCard) document.getElementById('header-spacer').style.height = (hCard.offsetHeight + 20) + 'px';
            }, 50);

            const scrollEl = document.getElementById('scroll-area');
            const headerLayer = document.getElementById('sticky-header');
            if (scrollEl && headerLayer) {
                scrollEl.onscroll = () => {
                    if (scrollEl.scrollTop > 30) headerLayer.classList.add('shrunk');
                    else headerLayer.classList.remove('shrunk');
                };
            }
        }

        // [추가] startQuizFromGroup 헬퍼 (헤더 버튼용)
        function startQuizFromGroup(groupId) {
            const sGroupId = String(groupId);
            const group = appData.groups.find(g => String(g.id) === sGroupId);
            // 그룹 처음부터(0) 시작하도록 호출
            quizSourceData = { langId: group.langId, mode: 'group', value: sGroupId, startIndex: 0 };
            showQuizModal(group.langId);
        }




        // --- Data Helpers ---
        function getCodeByLangId(id) {
            return appData.myLangs.find(l => l.id === id)?.code;
        }


        // --- [Global 추가] 편집용 ID 저장 변수 ---
        let editingWordId = null;

        // [JS Fix] 단어 추가 모달 (입력 초기화 강화)
        function openAddWordModal() {
            // 그룹 내에서만 추가 가능
            if (!currentGroupId) {
                alert("단어장 그룹 내에서만 단어를 추가할 수 있습니다.\n원하는 단어장을 먼저 클릭해주세요.");
                return;
            }

            editingWordId = null;
            renderWordModalContent(); // 폼 렌더링 (아래 함수 신설)
            openModalWithAnim('modal-add-word');
            setTimeout(() => document.getElementById('inp-term').focus(), 150);

            const group = appData.groups.find(g => g.id === currentGroupId);
            if (!group) return;

            const langCode = getCodeByLangId(group.langId);
            const langName = SUPPORTED_LANGS[langCode].name;

            // 제목 업데이트
            document.getElementById('modal-word-title').innerText = t('word_new');
            const langDisplay = document.getElementById('current-lang-display');
            if (langDisplay) langDisplay.innerText = langName;

            // 입력 필드 완전 초기화
            document.getElementById('inp-term').value = '';
            document.getElementById('inp-pron').value = '';
            document.getElementById('inp-mean').value = '';
            document.getElementById('inp-memo').value = '';
            document.getElementById('inp-tags').value = '';

            // 태그 목록 갱신
            renderAllTags(currentGroupId);
            openModalWithAnim('modal-add-word');

            setTimeout(() => document.getElementById('inp-term').focus(), 150);
        }

        // (5) 단어 편집 함수 (신규)
        function editWord(id) {
            const word = appData.words.find(w => w.id === id);
            if (!word) return;

            editingWordId = id; // 수정 모드 활성화
            renderWordModalContent(word);

            document.getElementById('modal-word-title').innerText = "단어 수정";
            document.getElementById('inp-term').value = word.term;
            document.getElementById('inp-pron').value = word.pron || '';
            document.getElementById('inp-mean').value = word.mean;
            document.getElementById('inp-memo').value = word.memo || '';
            document.getElementById('inp-tags').value = word.tags ? word.tags.join(', ') : '';
            // [추가] 태그 목록 보이기
            const currentWord = appData.words.find(w => w.id === id);
            // w.groupId가 필요하므로 데이터에서 가져옴
            if (currentWord) renderAllTags(currentWord.groupId);

            openModalWithAnim('modal-add-word');
        }


        /* --- [JS 수정] 단어 추가/수정 모달 (태그 스타일 롤백) --- */
        function renderWordModalContent(wordData = null) {
            const group = appData.groups.find(g => g.id === (wordData ? wordData.groupId : currentGroupId));
            if (!group) return;

            const langCode = getCodeByLangId(group.langId);
            const langName = SUPPORTED_LANGS[langCode].name;
            const titleText = wordData ? t('word_edit') : t('word_new');

            const termVal = wordData ? wordData.term : '';
            const pronVal = wordData ? (wordData.pron || '') : '';
            const meanVal = wordData ? wordData.mean : '';
            const memoVal = wordData ? (wordData.memo || '') : '';
            const tagsVal = wordData && wordData.tags ? wordData.tags.join(', ') : '';

            const modalPanel = document.querySelector('#modal-add-word .modal-panel');

            modalPanel.innerHTML = `
        <div class="modal-sticky-header">
            <button onclick="closeModal('modal-add-word')" class="back-icon-btn" style="border:none; background:none;">✕</button>
            <h3 id="modal-word-title" style="margin:0; font-size:1.1rem;">${titleText}</h3>
            <div style="width:40px;"></div>
        </div>

        <div class="modal-scroll-body">
            <p class="desc" style="text-align:center; margin-bottom:20px;">
                Target: <span style="color:var(--primary); font-weight:bold;">${langName}</span>
            </p>

            <div class="input-group">
                <span class="input-label">${t('term')}</span>
                <input type="text" id="inp-term" value="${termVal}" placeholder="e.g. Apple">
            </div>

            <div class="input-group">
                <span class="input-label">${t('pron')}</span>
                <input type="text" id="inp-pron" value="${pronVal}" placeholder="[æpl]">
            </div>

            <div class="input-group">
                <span class="input-label">${t('mean')}</span>
                <input type="text" id="inp-mean" value="${meanVal}" placeholder="사과">
            </div>

            <div class="input-group">
                <span class="input-label">${t('memo')}</span>
                <input type="text" id="inp-memo" value="${memoVal}" placeholder="I ate an apple.">
            </div>

            <!-- [수정됨] 태그 입력 및 추천 영역 디자인 롤백 -->
            <div class="input-group" style="position:relative;">
                <span class="input-label">${t('tags')}</span>
                <input type="text" id="inp-tags" value="${tagsVal}" placeholder="#Food #Fruit" oninput="filterTags(this.value)">
                
                <!-- 추천 태그들이 들어갈 영역 (칩 형태) -->
                <div id="tag-suggestions" style="margin-top:10px; display:flex; flex-wrap:wrap; gap:5px;"></div>
            </div>

            <div style="display:flex; gap:10px; margin-top:25px;">
                <button class="glass-btn primary" onclick="saveWord(false)" id="btn-save" style="flex:1;">${t('save')}</button>
                <button class="glass-btn primary" onclick="saveWord(true)" id="btn-save-cont" style="flex:1; border:1px solid var(--accent);">${t('save_cont')}</button>
            </div>
            <button class="glass-btn" onclick="closeModal('modal-add-word')" style="margin-top:10px;">${t('cancel')}</button>
            <div class="modal-footer-gap"></div>
        </div>
    `;

            // 태그 목록 렌더링 호출
            setTimeout(() => renderAllTags(group.id), 0);
        }

        /* --- [수정] 단어 상세 보기 모달 (편집 버튼 작동 수정) --- */
        /* --- [수정] 단어 상세 보기 모달 (삭제 버튼 추가) --- */
        /* [수정 3] 상세 모달: TTS, 즐겨찾기 버튼 추가 */
        function openWordDetail(wordId) {
            const word = appData.words.find(w => w.id === Number(wordId));
            if (!word) return;

            const langCode = getCodeByLangId(word.langId);

            // TTS 텍스트 (발음 우선)
            const ttsText = ((langCode === 'ja' || langCode === 'zh') && word.pron) ? word.pron : word.term;

            // 즐겨찾기 상태
            const isFav = word.isFav;
            const favColor = isFav ? '#FFD700' : 'var(--text-dim)';
            const favText = isFav ? '★' : '☆';
            const favBorder = isFav ? '#FFD700' : 'var(--glass-border)';

            const modalPanel = document.querySelector('#modal-word-detail .modal-panel');

            // 태그 HTML 생성 (기존 유지)
            let tagHtml = '';
            if (word.tags && word.tags.length > 0) {
                word.tags.forEach(t => {
                    tagHtml += `<span class="group-tag" style="font-size:0.9rem; margin-right:6px; padding:6px 10px;">#${t}</span>`;
                });
            } else {
                tagHtml = `<span style="color:var(--text-dim); font-size:0.9rem;">-</span>`;
            }

            modalPanel.innerHTML = `
        <div class="modal-sticky-header">
            <button onclick="closeModal('modal-word-detail')" class="back-icon-btn" style="border:none; background:none;">✕</button>
            <h3 style="margin:0; font-size:1.1rem;">${t('word_detail')}</h3>
            <button class="title-edit-btn" onclick="transitionToEdit(${word.id})" style="font-size:1.1rem; opacity:1;">✎</button>
        </div>
        
        <div class="modal-scroll-body">
            <div style="text-align:center; margin-bottom:20px;">
                <h1 style="margin:0; font-size:2.2rem; word-break:break-all;">${word.term}</h1>
                <div style="font-size:1.1rem; color:var(--accent); margin-top:5px;">${word.pron ? `[${word.pron}]` : ''}</div>
                
                <!-- [추가] 상세 화면 내 TTS 버튼 -->
                <button onclick="speak('${ttsText}', '${langCode}')" 
                    style="margin-top:10px; background:rgba(255, 255, 255, 0.05); border:1px solid var(--glass-border); border-radius:50%; width:44px; height:44px; font-size:1.2rem; cursor:pointer; color:var(--text-main);">
                    🔊
                </button>
            </div>

            <!-- (기존 상세 정보 카드들 유지) -->
            <div class="glass-card" style="margin-bottom:15px; padding:15px;">
                <span class="input-label">${t('mean')}</span>
                <div style="font-size:1.2rem; font-weight:600; color:var(--text-main);">${word.mean}</div>
            </div>

            <div class="glass-card" style="margin-bottom:15px; padding:15px;">
                <span class="input-label">${t('memo')}</span>
                <div style="font-size:1rem; color:var(--text-dim); line-height:1.5; min-height:20px;">${word.memo || '-'}</div>
            </div>

            <div style="margin-bottom:25px;">
                <span class="input-label" style="margin-bottom:8px;">${t('tags')}</span>
                <div style="display:flex; flex-wrap:wrap;">${tagHtml}</div>
            </div>

            <div style="display:flex; gap:10px;">
                <!-- 사전 버튼 -->
                <button onclick="openDictWindow('${word.term}', '${langCode}')" class="glass-btn primary" style="flex:2; background:linear-gradient(135deg, #03C75A, #02b350); border:none;">
                    ${t('dict_search')}
                </button>
                
                <!-- [추가] 즐겨찾기 버튼 -->
                <button id="btn-modal-fav" onclick="toggleFavorite(${word.id})" class="glass-btn" 
                        style="flex:1; font-size:1.5rem; padding:0; color:${favColor}; border-color:${favBorder};">
                    ${favText}
                </button>
            </div>
            
            <button onclick="deleteWordFromDetail(${word.id})" class="glass-btn" style="flex:1; margin-top:20px; color:var(--danger); border:1px solid var(--danger); background:rgba(255, 85, 119, 0.05);">
                ${t('delete')}
            </button>
            <div class="modal-footer-gap"></div>
        </div>
    `;

            openModalWithAnim('modal-word-detail');
        }

        /* --- [신규] 상세 모달에서 단어 삭제 (더블 체크 및 모달 닫기 포함) --- */
        function deleteWordFromDetail(wordId) {
            // 1. 더블 체크 팝업 (다국어 지원)
            if (!confirm(t('confirm_del'))) return;

            const id = Number(wordId);

            // 2. 삭제 대상 단어 찾기 (그룹 수정일 갱신을 위해)
            const targetWord = appData.words.find(w => w.id === id);
            if (targetWord) {
                const group = appData.groups.find(g => g.id === targetWord.groupId);
                if (group) {
                    group.modifiedAt = Date.now(); // 그룹 날짜 갱신
                }
            }

            // 3. 실제 데이터 삭제
            appData.words = appData.words.filter(w => w.id !== id);
            saveData();

            // 4. UI 정리: 모달 닫기 및 배경 리스트 갱신
            closeModal('modal-word-detail');

            // 모달이 닫히는 애니메이션을 위해 약간의 지연 후 렌더링하거나 즉시 렌더링
            renderApp();
        }







        /* --- [신규] 상세 모달 -> 편집 모달 안전 전환 함수 --- */
        function transitionToEdit(wordId) {
            // 1. 현재 상세 모달을 닫습니다 (history.back 호출)
            closeModal('modal-word-detail');

            // 2. 모달이 닫히는 애니메이션 및 히스토리 처리가 끝날 시간을 조금 줍니다.
            // 200ms 정도면 충분히 안전합니다.
            setTimeout(() => {
                editWord(wordId);
            }, 200);
        }



        // [단어 저장] 단어 추가/수정 시 그룹의 modifiedAt 갱신
        function saveWord(isContinue) {
            const term = document.getElementById('inp-term').value.trim();
            const mean = document.getElementById('inp-mean').value.trim();
            const pron = document.getElementById('inp-pron').value.trim();
            const memo = document.getElementById('inp-memo').value.trim();
            const rawTags = document.getElementById('inp-tags').value;
            const tags = rawTags.split(/[, ]+/).filter(t => t.trim() !== '').map(t => t.trim());

            if (!term || !mean) return alert(t('alert_input'));

            const defaultStats = { total: 0, wrong: 0, consecutiveCorrect: 0, lastResult: null, lastWrongType: null };

            // [중요] 단어가 속한 그룹 찾아서 수정일 갱신
            // (editingWordId가 있으면 그 단어의 groupId를, 없으면 currentGroupId 사용)
            let targetGroupId = currentGroupId;
            if (editingWordId) {
                const w = appData.words.find(w => w.id === editingWordId);
                if (w) targetGroupId = w.groupId;
            }
            const group = appData.groups.find(g => g.id === targetGroupId);
            if (group) {
                group.modifiedAt = Date.now(); // 날짜 갱신!
            }

            if (editingWordId) {
                // 수정 모드
                const idx = appData.words.findIndex(w => w.id === editingWordId);
                if (idx > -1) {
                    const w = appData.words[idx];
                    w.term = term; w.mean = mean; w.pron = pron; w.memo = memo;
                    w.tags = tags;
                }
                closeModal('modal-add-word');
                saveData();
                renderApp();
            } else {
                // 새 단어 추가
                // 그룹은 위에서 이미 찾았으므로 langId 획득 가능
                appData.words.unshift({
                    id: Date.now(),
                    groupId: currentGroupId,
                    langId: group.langId,
                    term, mean, memo, pron,
                    tags: tags,
                    stats: defaultStats,
                    created: Date.now()
                });
                saveData();

                if (isContinue) {
                    document.getElementById('inp-term').value = '';
                    document.getElementById('inp-mean').value = '';
                    document.getElementById('inp-pron').value = '';
                    document.getElementById('inp-memo').value = '';
                    document.getElementById('inp-term').focus();

                    const titleEl = document.getElementById('modal-word-title');
                    const originTxt = titleEl.innerText;
                    titleEl.innerText = t('saved_cont');
                    titleEl.style.color = "var(--primary)";
                    setTimeout(() => {
                        titleEl.innerText = originTxt;
                        titleEl.style.color = "";
                    }, 1000);

                    renderApp();
                } else {
                    closeModal('modal-add-word');
                    renderApp();
                }
            }
        }

        // [단어 삭제] 삭제 시에도 그룹 수정 날짜 갱신
        function deleteWord(id) {
            if (!confirm(t('confirm_del'))) return;

            // 삭제 대상 단어 찾기 (그룹 ID 알기 위해)
            const targetWord = appData.words.find(w => w.id === id);
            if (targetWord) {
                const group = appData.groups.find(g => g.id === targetWord.groupId);
                if (group) {
                    group.modifiedAt = Date.now(); // 날짜 갱신
                }
            }

            appData.words = appData.words.filter(w => w.id !== id);
            saveData();
            renderApp();
        }

        function closeModal(id) {

            history.back();
        }

        function openModalWithAnim(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            // [추가] 모달 열 때 히스토리 추가 (Level 3 - Modal)
            // 현재 보고있는 뷰 정보를 유지한채 모달임을 표시
            history.pushState({ level: 3, view: 'modal', modalId: modalId }, null, '');

            modal.style.display = 'flex';
            modal.style.opacity = '0';

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    modal.style.display = '';
                    modal.style.opacity = '';
                    modal.classList.add('active');
                });
            });
        }

        function resetData() {
            if (confirm(t('reset_confirm'))) {
                localStorage.removeItem(STORE_KEY);
                location.reload();
            }
        }

        /* --- [JS 수정] renderAllTags (태그 버튼 스타일 강제 적용) --- */
        function renderAllTags(currentGroupId) {
            const box = document.getElementById('tag-suggestions');
            // 안전장치: 요소가 없거나 그룹ID가 없으면 중단
            if (!box || !currentGroupId) return;

            // 그룹 찾기 (ID 타입 불일치 방지를 위해 문자열 비교)
            const group = appData.groups.find(g => String(g.id) === String(currentGroupId));
            if (!group) return;

            const langId = group.langId;

            // 해당 언어의 모든 태그 수집
            const wordsInLang = appData.words.filter(w => w.langId === langId);
            const allTags = new Set();
            wordsInLang.forEach(w => {
                if (w.tags && Array.isArray(w.tags)) {
                    w.tags.forEach(t => allTags.add(t));
                }
            });

            const sortedTags = Array.from(allTags).sort();

            // HTML 생성
            if (sortedTags.length === 0) {
                box.innerHTML = '';
            } else {
                // [핵심 수정] style 속성을 직접 넣어서 박스 디자인 강제 적용
                box.innerHTML = sortedTags.map(tag =>
                    `<div class="tag-chip" onclick="addTagToInput('${tag}')" 
                  style="display:inline-flex; align-items:center; gap:4px; 
                         background:rgba(255,255,255,0.1); 
                         border:1px solid var(--glass-border); 
                         border-radius:8px; padding:6px 12px; margin:0 6px 6px 0; 
                         font-size:0.85rem; color:var(--text-dim); cursor:pointer; user-select:none;">
                <span style="color:var(--accent);">#</span>${tag}
            </div>`
                ).join('');
            }
        }

        // 2. 검색어 입력 시 필터링 (선택 사항, 필요 없으면 oninput 제거해도 됨)
        function filterTags(val) {
            const box = document.getElementById('tag-suggestions');
            const chips = box.getElementsByClassName('tag-chip');
            const term = val.toLowerCase(); // 간단 검색

            // 이미 렌더링된 칩들을 숨기거나 보여줌
            Array.from(chips).forEach(chip => {
                // 태그 텍스트 가져오기 (샵(#) 제외)
                const text = chip.textContent.replace('#', '').trim().toLowerCase();
                if (text.includes(term) || term === "") {
                    chip.style.display = 'inline-flex';
                } else {
                    chip.style.display = 'none';
                }
            });
        }

        // 3. 칩 클릭 시 입력창에 태그 추가 (기존 기능 유지)
        function addTagToInput(tag) {
            const input = document.getElementById('inp-tags');
            let val = input.value.trim();

            // 이미 포함되어 있는지 확인 (중복 방지)
            const currentTags = val.split(/[, ]+/);
            if (currentTags.includes(tag)) return; // 이미 있으면 무시

            if (val.length > 0 && !val.endsWith(',')) {
                val += ', ';
            }
            input.value = val + tag;
            input.focus();
        }

        // [신규] 태그 추천 칩 클릭 시 입력창에 적용
        function applyTag(tag) {
            const input = document.getElementById('inp-tags');
            const parts = input.value.split(',');
            parts.pop(); // 지금 치고 있던(완성 안된) 조각 제거
            parts.push(tag); // 추천 태그 추가
            input.value = parts.join(', ') + ', '; // 쉼표 찍어주기
            input.focus();
            document.getElementById('tag-suggestions').innerHTML = ''; // 추천창 닫기
        }



        // ============================================
        // [JS 교체] 퀴즈 시스템 (이어하기, 특정 단어 시작)
        // ============================================

        // [2. 진입] 단어 리스트에서 ▶ 버튼 클릭 시 데이터 셋업
        function startQuizFromIndex(groupId, startIndex) {
            const sGroupId = String(groupId);
            const group = appData.groups.find(g => String(g.id) === sGroupId);

            if (!group) return alert("오류: 단어장을 찾을 수 없습니다.");

            // 진입 정보 설정
            quizSourceData = {
                langId: group.langId,
                mode: 'group',
                value: sGroupId,
                startIndex: Number(startIndex), // 사용자가 선택한 위치 (0이면 처음, 5면 5번 단어부터)
            };

            // 모달을 띄움
            showQuizModal(group.langId, sGroupId);
        }

        // [NEW] 스마트 그룹에서 특정 인덱스부터 퀴즈 시작
        function startQuizFromSmartGroup(startIndex) {
            if (!currentSmartView) return;

            // 스마트 그룹 정보 가져오기
            // langId는 화면 렌더링 시 사용했던 것을 그대로 쓰기 어려우므로(전역이 아님),
            // 현재 필터링된 첫 단어의 langId를 가져오거나, 
            // 혹은 전역 변수(currentTab이 숫자면 langId임)를 활용.
            let langId = (typeof currentTab === 'number') ? currentTab : null;

            // 만약 대시보드에서 들어온게 아니라면(혹시 모를 예외), 
            // filteredWords를 다시 구해서 langId 확인
            if (!langId) {
                // ... 로직이 복잡해지므로, 그냥 renderSmartGroupDetail 호출 시의 langId를 어딘가 저장했으면 좋았겠지만,
                // 현재 구조상 'currentTab'이 해당 언어 탭(숫자 ID)인 상태이므로 안전함.
            }

            const { mode, value } = currentSmartView;

            // 진입 정보 설정
            quizSourceData = {
                langId: currentTab, // 현재 보고있는 언어 탭 ID
                mode: mode,         // 'tag', 'wrong_last' 등
                value: value,       // 태그명 등
                startIndex: Number(startIndex), // 사용자가 누른 위치
                isResume: false     // 새 게임
            };

            // 모달 띄우기 (스마트 그룹은 groupId가 없으므로 null 전달 -> 이어하기 불가)
            showQuizModal(currentTab, null);
        }

        // 2. 스마트 그룹용 퀴즈 시작 (기존 유지)
        function startQuizSetup(langId, mode, value) {
            quizSourceData = { langId, mode, value, startIndex: 0, isResume: false };
            showQuizModal(langId, null);
        }

        // [3. 모달] 퀴즈 옵션 및 버튼 상태 관리 (디자인 구조 통일 적용)
        function showQuizModal(langId, groupId) {
            const langCode = getCodeByLangId(langId);
            const availableTypes = LANG_QUIZ_MAP[langCode] || LANG_QUIZ_MAP['default'];
            const modalPanel = document.querySelector('#modal-quiz-setup .modal-panel');

            let startBtnText = t('quiz_start');
            if (quizSourceData && quizSourceData.startIndex > 0) {
                startBtnText = t('quiz_start_idx');
            }

            let contBtnText = `${t('quiz_cont')} (N/A)`;
            let contBtnDisabled = true;
            let contBtnOpacity = "0.5";

            if (groupId) {
                const group = appData.groups.find(g => String(g.id) === String(groupId));
                const wordsInGroup = appData.words.filter(w => String(w.groupId) === String(groupId));
                const savedIndex = group.lastStopIndex || 0;

                if (wordsInGroup.length > 0 && savedIndex > 0 && savedIndex < wordsInGroup.length) {
                    contBtnDisabled = false;
                    contBtnOpacity = "1";
                    contBtnText = `${t('quiz_cont')} (${savedIndex + 1}~)`;
                    quizSourceData.resumeIndex = savedIndex;
                } else {
                    if (savedIndex >= wordsInGroup.length && wordsInGroup.length > 0) {
                        contBtnText = t('done');
                    } else {
                        contBtnText = `${t('quiz_cont')} (N/A)`;
                    }
                    quizSourceData.resumeIndex = 0;
                }
            }

            modalPanel.innerHTML = `
        <div class="modal-sticky-header">
            <button onclick="closeModal('modal-quiz-setup')" class="back-icon-btn" style="border:none; background:none; font-size:1.2rem;">✕</button>
            <h3 style="margin:0; font-size:1.1rem;">${t('quiz_setup')}</h3>
            <div style="width:40px;"></div>
        </div>

        <div class="modal-scroll-body">
            <div class="glass-card" style="padding:15px 20px; margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <span style="font-size:1rem; font-weight:500;">${t('tts_option')}</span>
                    <label class="ios-switch">
                        <input type="checkbox" id="chk-tts" checked>
                        <span class="ios-slider"></span>
                    </label>
                </div>
                <hr style="border:0; border-top:1px solid var(--glass-border); margin:0 0 15px 0; opacity:0.3;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:1rem; font-weight:500;">${t('random_option')}</span>
                    <label class="ios-switch">
                        <input type="checkbox" id="chk-random" onchange="toggleContinueBtn()">
                        <span class="ios-slider"></span>
                    </label>
                </div>
            </div>

            <div class="glass-card" style="padding:20px; margin-bottom:25px;">
                <div style="text-align:center; font-size:0.9rem; color:var(--text-dim); margin-bottom:10px;">
                    ${t('quiz_type_select')}
                </div>
                <div id="new-quiz-types-area" class="q-type-grid">
                    ${availableTypes.map(typ => `
                        <button class="q-type-btn active" data-value="${typ.id}" onclick="this.classList.toggle('active')">
                            ${t('q_type_' + typ.id)}
                        </button>
                    `).join('')}
                </div>
            </div>

            <div style="display:flex; gap:10px; margin-top:10px; flex-direction: column;">
                <button class="glass-btn primary" onclick="launchQuiz('start')" id="btn-quiz-start" style="height:50px; font-size:1.1rem;">${startBtnText}</button>
                <button class="glass-btn" id="btn-quiz-continue" onclick="launchQuiz('continue')" 
                        style="height:50px; font-size:1rem; opacity:${contBtnOpacity};" ${contBtnDisabled ? 'disabled' : ''}>
                    ${contBtnText}
                </button>
                <button class="glass-btn" onclick="closeModal('modal-quiz-setup')" style="margin-top:5px;">${t('cancel')}</button>
            </div>
            <div class="modal-footer-gap"></div>
        </div>
    `;

            openModalWithAnim('modal-quiz-setup');
        }
        // [4. 실행] 실제 퀴즈 데이터 슬라이싱 및 시작
        // [4. 실행] 버튼 활성화 상태(.active)를 읽어서 퀴즈 시작
        function launchQuiz(startMode) {
            const isOnline = navigator.onLine;
            let useTTS = document.getElementById('chk-tts').checked;
            const isRandom = document.getElementById('chk-random').checked;

            if (!isOnline && useTTS) {
                alert("오프라인 상태라 TTS가 비활성화됩니다.");
                useTTS = false;
            }

            // [수정된 부분] .q-type-btn 중 .active 클래스가 있는 요소들의 data-value를 가져옴
            const activeButtons = document.querySelectorAll('#new-quiz-types-area .q-type-btn.active');
            let selectedTypes = Array.from(activeButtons).map(btn => btn.dataset.value);

            if (selectedTypes.length === 0) return alert("최소 1개 이상의 문제 유형을 선택하세요.");
            if (!isOnline) selectedTypes = selectedTypes.filter(type => type !== 'tts_dict');

            // --- (이 아래 로직은 기존과 100% 동일) ---

            // 데이터 가져오기
            let targets = [];
            let isGroupMode = (quizSourceData.mode === 'group');

            if (isGroupMode) {
                targets = appData.words.filter(w => String(w.groupId) === String(quizSourceData.value));
            } else if (quizSourceData.mode === 'tag') {
                targets = appData.words.filter(w => w.langId === quizSourceData.langId && w.tags && w.tags.includes(quizSourceData.value)).reverse();
            } else if (quizSourceData.mode === 'wrong_last') {
                targets = appData.words.filter(w => w.langId === quizSourceData.langId && w.stats?.lastResult === 'wrong').reverse();
            } else if (quizSourceData.mode === 'wrong_freq') {
                targets = appData.words.filter(w => w.langId === quizSourceData.langId && (w.stats?.wrong || 0) >= 3).reverse();
            }

            if (targets.length === 0) return alert("학습할 단어가 없습니다.");

            let finalQueue = [];
            let initialIndex = 0;

            if (isRandom) {
                finalQueue = [...targets].sort(() => Math.random() - 0.5);
                initialIndex = 0;
            } else {
                if (startMode === 'continue') {
                    initialIndex = quizSourceData.resumeIndex || 0;
                } else {
                    initialIndex = quizSourceData.startIndex || 0;
                }

                if (initialIndex < targets.length) {
                    finalQueue = targets.slice(initialIndex);
                } else {
                    return alert("선택한 범위에 학습할 단어가 없습니다.");
                }
            }

            quizSession = {
                active: true,
                queue: finalQueue,
                cursor: 0,
                correctCnt: 0,
                targetGroupId: isGroupMode ? quizSourceData.value : null,
                absoluteStartIndex: initialIndex,
                isRandom: isRandom,
                config: { useTTS, types: selectedTypes }
            };

            closeModal('modal-quiz-setup');
            document.getElementById('quiz-screen').style.display = 'flex';
            showNextQuestion();
        }

        /* [수정 3-1] 퀴즈 진행상황 저장 로직 분리 (뒤로가기 대응) */
        function saveQuizProgress() {
            if (quizSession.active && quizSession.targetGroupId && !quizSession.isRandom) {
                const group = appData.groups.find(g => String(g.id) === String(quizSession.targetGroupId));
                if (group) {
                    group.lastQuizDate = Date.now();

                    // 점수 및 히스토리 기록 (기존 로직 유지)
                    const totalQ = quizSession.queue.length;
                    // 한 문제라도 풀었거나 퀴즈가 끝났을 때 기록
                    if (totalQ > 0) {
                        // 퀴즈 종료 여부와 상관없이 현재까지의 정답률 계산 등은 선택사항이나
                        // 여기서는 퀴즈가 끝까지 갔을 때만 히스토리에 남기는 기존 로직 유지
                        if (quizSession.cursor >= totalQ) {
                            const score = Math.round((quizSession.correctCnt / totalQ) * 100);
                            const wrongIds = quizSession.queue
                                .filter(w => w.stats && w.stats.lastResult === 'wrong')
                                .map(w => w.id);
                            if (!group.quizHistory) group.quizHistory = [];
                            group.quizHistory.push({ date: Date.now(), score: score, wrongWords: wrongIds });
                            if (group.quizHistory.length > 50) group.quizHistory.shift();
                        }
                    }

                    // [핵심] 이어하기를 위한 인덱스 저장
                    // 현재 커서 위치 + 시작 위치
                    const nextIndex = (quizSession.absoluteStartIndex || 0) + quizSession.cursor;
                    const wordsInGroup = appData.words.filter(w => String(w.groupId) === String(group.id));

                    // 끝까지 다 풀었으면 저장 인덱스를 전체 길이로(완료), 아니면 현재 위치 저장
                    if (nextIndex >= wordsInGroup.length) group.lastStopIndex = wordsInGroup.length;
                    else group.lastStopIndex = nextIndex;

                    saveData();
                }
            } else if (quizSession.active && quizSession.targetGroupId && quizSession.isRandom) {
                // 랜덤 모드여도 날짜는 갱신
                const group = appData.groups.find(g => String(g.id) === String(quizSession.targetGroupId));
                if (group) { group.lastQuizDate = Date.now(); saveData(); }
            }
        }

        // 기존 exitQuiz는 저장 함수 호출 후 뒤로가기 수행
        function exitQuiz() {
            saveQuizProgress(); // 저장 수행
            quizSession.active = false; // 세션 종료
            history.back(); // UI 닫기 (onpopstate 트리거)
        }

        // 6. UI 제어
        function toggleContinueBtn() {
            const isRandom = document.getElementById('chk-random').checked;
            const btnCont = document.getElementById('btn-quiz-continue');

            if (isRandom) {
                btnCont.disabled = true;
                btnCont.style.opacity = 0.5;
                // 텍스트는 건드리지 않고 비활성화만
            } else {
                // 랜덤 끄면 다시 활성화 체크 (기존에 활성화 상태였다면)
                // 여기서는 단순하게 quizSourceData.resumeIndex가 있으면 활성화시킴
                if (quizSourceData && quizSourceData.resumeIndex > 0) {
                    btnCont.disabled = false;
                    btnCont.style.opacity = 1;
                }
            }
        }

        /* --- [신규] 기능성/기초 상용 한자 풀 (30개) --- */
        // 동사, 형용사, 명사 구조를 만들 때 어색하지 않은 기본 한자들
        const FALLBACK_KANJI_POOL = [
            '取', '駆', '書', '掛', '思', '間', '合', '人', '上', '見', // 형용사적 성격
            '助', '来', '行', '引', '追', '切', '聞', '押', '言', '抱', // 동사적 성격
            '出', '入', '立', '戻', '止', '放', '抜', '動', '通', '下', // 동작/상태
            '進', '気', '始', '詰', '事', '向', '任', '遂', '乗', '打', // 동작/상태
            '続', '直', '渡', '込', '受', '付', '分', '当', '決', '重'   // 명사적 성격
        ];

        function generateFakeKanjiVariations(term, count = 3) {
            if (!term) return [];

            // 구조 분해: 한자([一-龯]+) 덩어리와 그 외 분리
            // 예: "編み物" -> ["", "編", "み", "物", ""]
            const tokens = term.split(/([一-龯]+)/);

            // 이 단어가 [한자 + 히라가나 + 한자] 같은 복합 구조인지 체크
            // (한자 덩어리가 2개 이상이고, 중간에 히라가나가 있는 경우)
            const kanjiChunks = tokens.filter(t => /^[一-龯]+$/.test(t));
            const hasKanaMiddle = /[\u3040-\u309F]/.test(term);
            const shouldProtectSuffix = (kanjiChunks.length >= 2 && hasKanaMiddle);

            // 마지막 한자 덩어리의 인덱스 찾기
            let lastKanjiIndex = -1;
            if (shouldProtectSuffix) {
                for (let i = tokens.length - 1; i >= 0; i--) {
                    if (/^[一-龯]+$/.test(tokens[i])) {
                        lastKanjiIndex = i;
                        break;
                    }
                }
            }

            const results = new Set();
            let safety = 0;

            // 더 다양한 한자 풀 (모양/의미 그럴싸한 것들)
            const ADVANCED_POOL = [
                '取', '駆', '書', '掛', '思', '間', '合', '的', '上', '見', // 형용사적 성격
                '助', '来', '行', '引', '追', '切', '聞', '押', '言', '抱', // 동사적 성격
                '出', '入', '立', '戻', '止', '放', '抜', '動', '通', '下', // 동작/상태
                '進', '気', '始', '詰', '事', '向', '任', '遂', '乗', '打', // 동작/상태
                '編', '組', '案', '建', '設', '定', '決', '選', '択', '発'
            ];

            while (results.size < count && safety < 50) {
                let fakeWord = "";
                let mutated = false;

                tokens.forEach((token, index) => {
                    if (/^[一-龯]+$/.test(token)) {
                        // ★ 핵심 수정: 복합어 구조면 마지막 한자는 보호 (예: '物' 유지)
                        if (shouldProtectSuffix && index === lastKanjiIndex) {
                            fakeWord += token;
                        } else {
                            // 앞부분 한자는 랜덤 교체
                            let replacement = "";
                            for (let i = 0; i < token.length; i++) {
                                const randKanji = ADVANCED_POOL[Math.floor(Math.random() * ADVANCED_POOL.length)];
                                replacement += randKanji;
                            }
                            fakeWord += replacement;
                            mutated = true;
                        }
                    } else {
                        // 히라가나 등은 그대로 유지
                        fakeWord += token;
                    }
                });

                // 원본과 다르고, 빈 문자열이 아니면 추가
                if (mutated && fakeWord !== term && fakeWord.trim() !== "") {
                    results.add(fakeWord);
                }
                safety++;
            }

            return Array.from(results);
        }


        /* --- [신규] 1. 일본어 단어 구조 분석기 (한자/히라가나 분리) --- */
        function parseJapaneseStructure(term, reading) {
            // 1. 단어(Term)에서 히라가나 덩어리(Okurigana)들을 추출
            // 예: 立ち止まる -> ['ち', 'まる']
            const kanaChunks = term.match(/[\u3040-\u309F]+/g);

            if (!kanaChunks) {
                // 히라가나가 없으면 전체가 변형 대상 (예: 以外 -> 전체)
                return [{ text: reading, type: 'mutable' }];
            }

            // 2. 히라가나 덩어리를 기준으로 정규식 생성
            // 예: 立ち止まる -> /^(.*?)ち(.*?)まる(.*)$/
            let regexStr = "^";
            kanaChunks.forEach(chunk => {
                regexStr += "(.*?)" + chunk;
            });
            regexStr += "(.*)$";

            const regex = new RegExp(regexStr);
            const match = reading.match(regex);

            if (!match) {
                // 매칭 실패 시 (숙자훈 등) 그냥 전체를 하나로 취급
                return [{ text: reading, type: 'mutable' }];
            }

            // 3. 구조화된 배열 생성
            // 예: [{t:'た', type:'mutable'}, {t:'ち', type:'fixed'}, {t:'ど', type:'mutable'}, {t:'まる', type:'fixed'}]
            const structure = [];
            for (let i = 1; i < match.length; i++) {
                if (match[i]) structure.push({ text: match[i], type: 'mutable' }); // 한자 부분 발음
                if (kanaChunks[i - 1]) structure.push({ text: kanaChunks[i - 1], type: 'fixed' }); // 오쿠리가나
            }
            return structure;
        }

        /* --- [신규] 2. 확률 기반 변형 생성기 --- */
        function applyKanaMutation(text, probSettings) {
            if (!text) return text;

            // 변환 맵 (탁음↔청음, 반탁음↔청음)
            const dakutenMap = {
                'か': 'が', 'き': 'ぎ', 'く': 'ぐ', 'け': 'げ', 'こ': 'ご',
                'さ': 'ざ', 'し': 'じ', 'す': 'ず', 'せ': 'ぜ', 'そ': 'ぞ',
                'た': 'だ', 'ち': 'ぢ', 'つ': 'づ', 'て': 'で', 'と': 'ど',
                'は': 'ば', 'ひ': 'び', 'ふ': 'ぶ', 'へ': 'べ', 'ほ': 'ぼ',
                'が': 'か', 'ぎ': 'き', 'ぐ': 'く', 'げ': 'け', 'ご': 'こ',
                'ざ': 'さ', 'じ': 'し', 'ず': 'す', 'ぜ': 'せ', 'ぞ': 'そ',
                'だ': 'た', 'ぢ': 'ち', 'づ': 'つ', 'で': 'て', 'ど': 'と',
                'ば': 'は', 'び': 'ひ', 'ぶ': 'ふ', 'べ': 'へ', 'ぼ': 'ほ'
            };

            // 확률 추첨
            const rand = Math.random() * 100;
            let action = 'none';
            let cumulative = 0;

            if (rand < (cumulative += probSettings.dakuten)) action = 'dakuten';
            else if (rand < (cumulative += probSettings.chouon)) action = 'chouon';
            else if (rand < (cumulative += probSettings.sokuon)) action = 'sokuon';
            else if (rand < (cumulative += probSettings.mix)) action = 'mix';

            let result = text;
            const chars = text.split('');

            if (action === 'dakuten' || action === 'mix') {
                // 가능한 모든 글자를 바꾸는 게 아니라, 랜덤하게 1~2개만 바꿈
                const indices = chars.map((c, i) => dakutenMap[c] ? i : -1).filter(i => i !== -1);
                if (indices.length > 0) {
                    const targetIdx = indices[Math.floor(Math.random() * indices.length)];
                    chars[targetIdx] = dakutenMap[chars[targetIdx]];
                    result = chars.join('');
                }
            }

            if (action === 'chouon' || action === 'mix') {
                // 끝에 장음 추가 (단, 'っ'으로 끝나면 제외)
                if (!result.endsWith('っ')) {
                    const last = result.slice(-1);
                    if (['お', 'こ', 'そ', 'と', 'の', 'ほ', 'も', 'よ', 'ろ', 'ご', 'ぞ', 'ど', 'ぼ', 'ぽ'].includes(last)) result += 'う';
                    else if (['え', 'け', 'せ', 'へ', 'め', 'れ', 'げ'].includes(last)) result += 'い';
                }
            }

            if (action === 'sokuon') {
                if (result.includes('っ')) result = result.replace('っ', '');
                else if (result.length >= 2) {
                    const mid = Math.floor(result.length / 2);
                    result = result.slice(0, mid) + 'っ' + result.slice(mid);
                }
            }

            return result;
        }

        /* --- [신규] 3. 변형 통합 관리자 --- */
        function generateSmartVariations(reading, term, count = 1) {
            const parts = parseJapaneseStructure(term, reading);

            // 오쿠리가나가 있는지 확인 (fixed 타입 존재 여부)
            const hasOkurigana = parts.some(p => p.type === 'fixed');

            // 확률 설정 (사용자 정의)
            const probs = hasOkurigana
                ? { dakuten: 70, chouon: 20, mix: 5, sokuon: 5 } // 오쿠리가나 있음: 탁음화 위주
                : { dakuten: 60, chouon: 30, mix: 5, sokuon: 5 }; // 한자어: 장음화 비율 높임

            const results = new Set();
            let safeGuard = 0;

            while (results.size < count && safeGuard < 20) {
                let variedStr = "";
                let mutated = false;

                parts.forEach(p => {
                    if (p.type === 'fixed') {
                        variedStr += p.text; // 고정부는 그대로
                    } else {
                        // 가변부(한자 발음)만 변형 시도
                        const newText = applyKanaMutation(p.text, probs);
                        if (newText !== p.text) mutated = true;
                        variedStr += newText;
                    }
                });

                // 원본과 다르고, 빈 문자열이 아니면 추가
                if (mutated && variedStr !== reading) {
                    results.add(variedStr);
                }
                safeGuard++;
            }

            return Array.from(results);
        }

        /* --- [신규/누락분] 5. 히라가나 읽기 강제 변형 생성기 (Fallback) --- */
        function generateFallbackVariations(reading, term, count = 3) {
            if (!reading) return [];

            // 구조 분해: 오쿠리가나(fixed)와 어간(mutable) 분리
            const parts = parseJapaneseStructure(term, reading);
            let stem = "";
            let suffix = "";

            parts.forEach(p => {
                if (p.type === 'fixed') suffix += p.text;
                else stem += p.text;
            });

            // 변형할 앞부분이 없으면 빈 배열 반환
            if (!stem) return [];

            const results = new Set();
            const chars = stem.split('');

            // 무작위로 교체할 히라가나 풀
            const randomKana = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわ";

            let safety = 0;
            while (results.size < count && safety < 50) {
                let newChars = [...chars];

                // 전략: 첫 글자를 무작위 히라가나로 교체 (가장 쉬운 변형)
                // 예: た(ta) -> ま(ma) => まちどまる
                if (newChars.length > 0) {
                    newChars[0] = randomKana[Math.floor(Math.random() * randomKana.length)];
                }

                // 단어가 3글자 이상이면 중간 글자도 가끔 교체해서 다양성 확보
                if (newChars.length > 2 && Math.random() > 0.7) {
                    newChars[1] = randomKana[Math.floor(Math.random() * randomKana.length)];
                }

                const fakeWord = newChars.join('') + suffix;

                // 정답과 다르면 추가
                if (fakeWord !== reading) {
                    results.add(fakeWord);
                }
                safety++;
            }

            return Array.from(results);
        }

        /* --- [수정] 4. 점수 계산기 (히라가나 구조 유사성 검사 강화) --- */
        /* --- [수정] 4. 점수 계산기 (한자 구조 마스킹 기법 적용) --- */
        function getSimilarityScore(wordA, wordB) {
            let score = 0;

            // 1. 기본 길이 유사성
            const lenDiff = Math.abs(wordA.term.length - wordB.term.length);
            if (lenDiff === 0) score += 10;
            else if (lenDiff === 1) score += 5;

            // 2. 일본어 구조(패턴) 비교
            // 정규식: 한자 범위
            const isJPA = /[\u4e00-\u9faf]/.test(wordA.term) && /[\u3040-\u309F]/.test(wordA.term);
            const isJPB = /[\u4e00-\u9faf]/.test(wordB.term) && /[\u3040-\u309F]/.test(wordB.term);

            if (isJPA && isJPB) {
                // 한자를 '▣'로 치환하여 뼈대(Skeleton) 생성
                // 예: 編み物 -> ▣み▣, 恨み -> ▣み
                const getStructureMask = (str) => str.replace(/[\u4e00-\u9faf]+/g, '▣');

                const maskA = getStructureMask(wordA.term);
                const maskB = getStructureMask(wordB.term);

                if (maskA === maskB) {
                    score += 50; // ▣み▣ == ▣み▣ (구조 완벽 일치 -> 높은 점수)
                } else if (maskA.slice(-1) === maskB.slice(-1)) {
                    // 끝부분 형태라도 같으면 점수 (예: ~み)
                    score += 10;
                }
            }

            // 3. 한자(CJK) 공유 여부 (글자 자체 매칭)
            if (/[\u4e00-\u9faf]/.test(wordA.term) && /[\u4e00-\u9faf]/.test(wordB.term)) {
                const overlap = wordA.term.split('').filter(char => wordB.term.includes(char) && /[\u4e00-\u9faf]/.test(char));
                if (overlap.length > 0) score += 30;
            }

            // 4. 영어 등 기타 언어 (접두/접미)
            if (wordA.term.length > 4 && wordB.term.length > 4) {
                if (wordA.term.substring(0, 3) === wordB.term.substring(0, 3)) score += 20;
                if (wordA.term.slice(-3) === wordB.term.slice(-3)) score += 20;
            }

            return score;
        }

        /* --- [신규] 중국어 핀인 변형 생성기 (성조/자음 조작) --- */
        function generatePinyinVariations(text) {
            if (!text) return [];
            const variations = new Set();

            // 1. 성조 숫자 변경 (hao3 -> hao1, hao4) - 숫자 표기 방식일 경우
            if (/[1-5]/.test(text)) {
                variations.add(text.replace(/[1-5]/g, '1'));
                variations.add(text.replace(/[1-5]/g, '2'));
                variations.add(text.replace(/[1-5]/g, '3'));
                variations.add(text.replace(/[1-5]/g, '4'));
            } else {
                // 성조 마크 방식일 경우 (ā -> á, à 등) - 간단히 처리하거나 패스
                // (여기서는 복잡성을 피하기 위해 자음 변형에 집중)
            }

            // 2. 헷갈리는 자음/모음 교체 (z<->zh, c<->ch, s<->sh, l<->n, in<->ing)
            let temp = text;
            if (temp.includes('zh')) variations.add(temp.replace('zh', 'z'));
            else if (temp.includes('z')) variations.add(temp.replace('z', 'zh'));

            if (temp.includes('ch')) variations.add(temp.replace('ch', 'c'));
            else if (temp.includes('c')) variations.add(temp.replace('c', 'ch'));

            if (temp.includes('sh')) variations.add(temp.replace('sh', 's'));
            else if (temp.includes('s')) variations.add(temp.replace('s', 'sh'));

            if (temp.includes('ing')) variations.add(temp.replace('ing', 'in'));
            else if (temp.includes('in')) variations.add(temp.replace('in', 'ing'));

            return Array.from(variations);
        }

        /* [수정 2-1] 뜻 정규화 및 Prefix 추출 헬퍼 함수 추가 */
        function getNormalizedMeaningPrefix(text, langCode) {
            if (!text) return "";
            // 1. 괄호 (...) 및 [...] 와 그 안의 내용 제거
            let clean = text.replace(/\(.*?\)/g, '').replace(/\[.*?\]/g, '').trim();

            // 2. 언어별 비교 길이 설정
            // ko(한국어), zh(중국어): 3글자
            // en(영어), es(스페인어): 5글자
            // ja(일본어): 4글자
            // 그 외: 4글자
            let len = 4;
            if (langCode === 'ko' || langCode === 'zh') len = 3;
            else if (langCode === 'en' || langCode === 'es') len = 5;

            // 공백 제거 후 소문자로 변환하여 앞글자 추출
            return clean.replace(/\s+/g, '').toLowerCase().substring(0, len);
        }

        // 4. 문제 렌더링
        /* --- [New] Helper for text normalization (removes parentheses, spaces for comparison) --- */
        function getCleanText(text) {
            if (!text) return "";
            // Remove content in parentheses, special chars, spaces, and lowercase it
            return text.replace(/\(.*?\)/g, '').replace(/\[.*?\]/g, '').replace(/\s+/g, '').toLowerCase();
        }

        /* --- [New] Helper for text normalization (removes parentheses, spaces for comparison) --- */
        function getCleanText(text) {
            if (!text) return "";
            // Remove content in parentheses, special chars, spaces, and lowercase it
            return text.replace(/\(.*?\)/g, '').replace(/\[.*?\]/g, '').replace(/\s+/g, '').toLowerCase();
        }

        /* --- [Updated] showNextQuestion (Fixes okurigana matching & duplicates) --- */
        function showNextQuestion() {
            if (quizSession.cursor >= quizSession.queue.length) {
                alert(t('quiz_finish_alert', { n: Math.round((quizSession.correctCnt / quizSession.queue.length) * 100) }));
                return exitQuiz();
            }

            const word = quizSession.queue[quizSession.cursor];
            const langCode = getCodeByLangId(word.langId);

            const ui = {
                bar: document.getElementById('quiz-progress-bar'),
                txt: document.getElementById('quiz-progress-text'),
                badge: document.getElementById('q-type-badge'),
                qText: document.getElementById('q-text'),
                area: document.getElementById('q-answer-area'),
                feedback: document.getElementById('q-feedback'),
                ttsBtn: document.getElementById('q-tts-btn')
            };

            const progress = ((quizSession.cursor) / quizSession.queue.length) * 100;
            ui.bar.style.width = `${progress}%`;
            ui.txt.innerText = `${quizSession.cursor + 1} / ${quizSession.queue.length}`;
            ui.feedback.style.display = 'none';
            ui.area.innerHTML = '';

            // Determine quiz type
            let qType = null;
            const availTypes = quizSession.config.types;
            if (word.stats && word.stats.lastResult === 'wrong' && word.stats.lastWrongType) {
                if (availTypes.includes(word.stats.lastWrongType)) qType = word.stats.lastWrongType;
            }
            if (!qType) qType = availTypes[Math.floor(Math.random() * availTypes.length)];
            quizSession.currentQType = qType;

            // Set question text
            let questionText = word.term;
            let isTTSQuestion = false;
            let displayKey = 'mean';

            ui.badge.innerText = t('q_type_' + qType) || "Quiz";

            switch (qType) {
                case 'sel_l2m': displayKey = 'mean'; break;
                case 'sel_m2l': case 'j_sel_m2k':
                    questionText = word.mean;
                    displayKey = 'term'; // Correct answer is Kanji Term
                    break;
                case 'j_sel_k2h': displayKey = 'pron_or_term'; break;
                case 'tts_dict':
                    questionText = "🎧 Listen";
                    isTTSQuestion = true;
                    displayKey = 'mean';
                    break;
                case 'typ_spell': case 'j_typ_spell': questionText = word.mean; break;
                case 'j_wri_chk': questionText = `${word.mean} ${word.pron ? `[${word.pron}]` : ''}`; break;
            }

            ui.qText.innerText = questionText;
            ui.ttsBtn.style.display = (isTTSQuestion || quizSession.config.useTTS) ? 'inline-block' : 'none';

            if (isTTSQuestion) {
                const textToSpeak = ((langCode === 'ja' || langCode === 'zh') && word.pron) ? word.pron : word.term;
                speak(textToSpeak, langCode);
            }

            // ============================================
            // [Core Logic] 4-Choice Selection
            // ============================================
            if (qType.includes('sel') || qType === 'tts_dict') {

                // Get the text value of the correct answer that will be displayed
                let correctDisplayVal = (displayKey === 'mean') ? word.mean :
                    (displayKey === 'pron_or_term') ? (word.pron || word.term) : word.term;
                correctDisplayVal = correctDisplayVal ? correctDisplayVal.trim() : "";
                const cleanCorrectVal = getCleanText(correctDisplayVal); // Normalized text for comparison

                // ★ [Japanese Structure Analysis]
                // Trim inputs to avoid regex failure on trailing spaces
                const cleanTerm = word.term.trim();
                const termSuffixMatch = cleanTerm.match(/[\u3040-\u309F]+$/);
                const hasKanji = /[\u4e00-\u9faf]/.test(cleanTerm);
                // Correct suffix (e.g., 're' from 'oshiire')
                const correctSuffix = (langCode === 'ja' && hasKanji && termSuffixMatch) ? termSuffixMatch[0] : "";


                // 1. Initial Candidate Filtering
                const correctPron = (word.pron || word.term).replace(/\s+/g, '').toLowerCase();
                // 뜻이 담긴 언어(모국어)의 코드는 시스템 설정(appData.config.sysLang)을 따름
                const sysLang = appData.config.sysLang || 'ko';
                const correctMeanPrefix = getNormalizedMeaningPrefix(word.mean, sysLang);

                const candidates = appData.words.filter(w => {
                    // 기본 조건: 같은 언어여야 하고, 자기 자신은 제외
                    if (w.langId !== word.langId) return false;
                    if (w.id === word.id) return false;

                    // A. 단어(Term)가 완전히 같으면 배제 (동의어 등)
                    if (w.term.trim() === word.term.trim()) return false;

                    // B. 발음(Pron)이 동일하면 배제 (예: 同音異義語 방지)
                    const wPron = (w.pron || w.term).replace(/\s+/g, '').toLowerCase();
                    if (wPron === correctPron) return false;

                    // C. 뜻(Mean)이 유사하면 배제 (언어별 앞글자 비교)
                    const wMeanPrefix = getNormalizedMeaningPrefix(w.mean, sysLang);
                    // 접두어가 비어있지 않고 서로 같다면 배제 (너무 비슷한 뜻)
                    if (correctMeanPrefix.length > 0 && wMeanPrefix === correctMeanPrefix) return false;

                    // D. (기존 로직) 정답 텍스트가 후보군에 포함되거나 반대의 경우 배제
                    let wVal = (displayKey === 'mean') ? w.mean : (displayKey === 'pron_or_term') ? (w.pron || w.term) : w.term;
                    wVal = wVal ? wVal.trim() : "";

                    if (wVal === correctDisplayVal) return false;
                    const cleanWVal = getCleanText(wVal);
                    if (cleanWVal === cleanCorrectVal) return false;

                    if (cleanCorrectVal.length > 1 && cleanWVal.length > 1) {
                        if (cleanWVal.includes(cleanCorrectVal) || cleanCorrectVal.includes(cleanWVal)) return false;
                    }

                    // E. (기존 일본어 로직 유지) 정답이 오쿠리가나를 포함하면 후보도 동일해야 함
                    if (displayKey === 'term' && correctSuffix.length > 0) {
                        if (!w.term.trim().endsWith(correctSuffix)) return false;
                    }

                    return true;
                });

                let choices = [];
                const isJP_Reading = (langCode === 'ja' && qType === 'j_sel_k2h');

                if (isJP_Reading) {
                    // === [Japanese Reading Quiz] (Hiragana Selection) ===
                    const correctReading = word.pron || word.term;
                    const usedTexts = new Set([correctReading]);
                    const distractors = [];

                    // A-1. Score Candidates (Strict suffix filtering again just in case)
                    const scoredCandidates = candidates.map(w => {
                        const wRead = w.pron || w.term;
                        // If the candidate reading doesn't match the suffix, discard it
                        if (correctSuffix.length > 0 && !wRead.endsWith(correctSuffix)) return null;

                        let score = getSimilarityScore(word, w);
                        if (correctSuffix.length > 0) score += 20;
                        return { w, score };
                    }).filter(item => item !== null).sort((a, b) => b.score - a.score);

                    // A-2. Generate Variation of Correct Answer (Priority 1)
                    const correctVars = generateSmartVariations(correctReading, word.term, 3);
                    for (let v of correctVars) {
                        if (!usedTexts.has(v)) { distractors.push({ text: v }); usedTexts.add(v); break; }
                    }

                    // A-3. Pick Real Similar Word (Priority 2)
                    let similarItem = null;
                    if (scoredCandidates.length > 0) {
                        const pool = scoredCandidates.slice(0, 6);
                        similarItem = pool[Math.floor(Math.random() * pool.length)].w;
                    }

                    if (similarItem) {
                        const simRead = similarItem.pron || similarItem.term;
                        if (!usedTexts.has(simRead)) {
                            distractors.push({ text: simRead });
                            usedTexts.add(simRead);
                        } else {
                            // If real word is duplicate, try variation of it
                            const simVars = generateSmartVariations(simRead, similarItem.term, 3);
                            for (let v of simVars) {
                                if (!usedTexts.has(v)) {
                                    distractors.push({ text: v });
                                    usedTexts.add(v);
                                    break;
                                }
                            }
                        }
                    }

                    // A-4. Fill Remaining Spots
                    let loop = 0;
                    while (distractors.length < 3 && loop < 30) {
                        let added = false;

                        // 1) More Correct Answer Variations
                        const moreVars = generateSmartVariations(correctReading, word.term, 10);
                        const pickVar = moreVars.find(v => !usedTexts.has(v));
                        if (pickVar) { distractors.push({ text: pickVar }); usedTexts.add(pickVar); added = true; }

                        // 2) [Fallback] Forced Generator (Swap starting chars) -> Use this when DB is empty
                        if (!added) {
                            const fallback = generateFallbackVariations(correctReading, word.term, 5);
                            const pickFall = fallback.find(v => !usedTexts.has(v));
                            if (pickFall) { distractors.push({ text: pickFall }); usedTexts.add(pickFall); added = true; }
                        }

                        // 3) Random DB Word (must match suffix)
                        if (!added && scoredCandidates.length > 0) {
                            const randW = scoredCandidates[Math.floor(Math.random() * scoredCandidates.length)].w;
                            const rRead = randW.pron || randW.term;
                            if (!usedTexts.has(rRead)) { distractors.push({ text: rRead }); usedTexts.add(rRead); added = true; }
                        }

                        loop++;
                        // Break if infinite loop possible
                    }

                    choices = [
                        { id: word.id, text: correctReading, isCorrect: true },
                        ...distractors.slice(0, 3).map((d, i) => ({ id: `fake_${i}`, text: d.text, isCorrect: false }))
                    ];

                } else {

                    // 점수 매기기 (구조가 비슷한 단어 찾기)
                    const scoredCandidates = candidates.map(w => {
                        return { wordData: w, score: getSimilarityScore(word, w) };
                    }).sort((a, b) => b.score - a.score);

                    const selectedWords = [];
                    const usedDisplayVals = new Set();
                    usedDisplayVals.add(correctDisplayVal);

                    const tryAddCandidate = (candidate, isRawData = true) => {
                        let val = "";
                        // 후보의 원본 뜻(mean) 데이터가 필요함 (중복 검사용)
                        let candidateMean = "";

                        if (isRawData) {
                            val = (displayKey === 'mean') ? candidate.mean :
                                (displayKey === 'pron_or_term') ? (candidate.pron || candidate.term) : candidate.term;
                            candidateMean = candidate.mean;
                        } else {
                            val = candidate;
                            // RawData가 아닐 경우(가짜 생성 등), val 자체가 뜻일 수 있음
                            if (displayKey === 'mean') candidateMean = candidate;
                        }

                        val = val ? val.trim() : "";

                        // [기존 1차 필터] 단순 텍스트 중복 확인
                        if (usedDisplayVals.has(val)) return false;

                        // [수정 2차 필터] 오답간 의미 중복 엄격 검사 (Issue 2 해결)
                        // 문제 유형이 '뜻 고르기(sel_l2m, tts_dict)'일 때만 작동 (displayKey === 'mean')
                        if (displayKey === 'mean') {
                            const sysLang = appData.config.sysLang || 'ko';
                            const currentPrefix = getNormalizedMeaningPrefix(val, sysLang);

                            // 1. 정답과의 의미 중복 재확인 (방어 코드)
                            if (currentPrefix === getNormalizedMeaningPrefix(word.mean, sysLang)) return false;

                            // 2. 이미 선택된 오답(selectedWords)들과의 의미 중복 확인
                            for (let added of selectedWords) {
                                // added.text는 화면에 표시될 텍스트(뜻)임
                                const addedPrefix = getNormalizedMeaningPrefix(added.text, sysLang);
                                if (currentPrefix === addedPrefix) return false;
                            }
                        }

                        // 통과되면 추가
                        selectedWords.push({
                            id: isRawData ? candidate.id : `gen_${Math.random()}`,
                            text: val
                        });
                        usedDisplayVals.add(val);
                        return true;
                    };

                    // 1. 유사도가 높은 단어 (구조가 같은 단어) 우선 채택
                    // 점수 컷오프: 40점 이상이면 구조가 매우 유사한 것임 (getSimilarityScore 로직 참고)
                    const highSimPool = scoredCandidates.filter(item => item.score >= 40).slice(0, 4);

                    for (let item of highSimPool) {
                        if (selectedWords.length >= 3) break;
                        // 너무 많이 뽑지 않고 랜덤성을 위해 50% 확률로만 선택 (다양성)
                        if (Math.random() > 0.3) {
                            tryAddCandidate(item.wordData, true);
                        }
                    }

                    // 2. [★핵심 보완] 한자 단어 문제라면, 구조적 가짜 단어(Fallback) 적극 생성
                    // 유사한 단어(오답)가 DB에 부족하면 바로 가짜 생성기로 넘어감
                    if (displayKey === 'term' && langCode === 'ja' && selectedWords.length < 3) {
                        if (/[\u4e00-\u9faf]/.test(word.term)) {
                            // 10개 정도 넉넉히 만듦
                            const fakes = generateFakeKanjiVariations(word.term, 10);
                            // 랜덤하게 섞어서 추가
                            fakes.sort(() => Math.random() - 0.5);

                            for (const fake of fakes) {
                                if (selectedWords.length >= 3) break;
                                tryAddCandidate(fake, false);
                            }
                        }
                    }

                    // 3. 그래도 부족하면 유사도 차순위에서 랜덤 충원
                    if (selectedWords.length < 3) {
                        const remaining = scoredCandidates.slice(0, 20) // 상위 20개 중에서
                            .filter(item => !selectedWords.some(sw => sw.id === item.wordData.id))
                            .map(item => item.wordData)
                            .sort(() => Math.random() - 0.5);

                        while (selectedWords.length < 3 && remaining.length > 0) {
                            tryAddCandidate(remaining.pop(), true);
                        }
                    }

                    // 4. 정말 답이 없으면 전체 랜덤 충원
                    if (selectedWords.length < 3) {
                        const totalRandom = candidates.sort(() => Math.random() - 0.5);
                        while (selectedWords.length < 3 && totalRandom.length > 0) {
                            tryAddCandidate(totalRandom.pop(), true);
                        }
                    }

                    choices = [
                        { id: word.id, text: correctDisplayVal, isCorrect: true },
                        ...selectedWords.map(w => ({ id: w.id, text: w.text, isCorrect: false }))
                    ];
                }

                // Shuffle choices
                choices.sort(() => Math.random() - 0.5);

                // Render
                choices.forEach(ch => {
                    const btn = document.createElement('button');
                    btn.className = 'choice-btn';
                    btn.innerText = ch.text;
                    btn.onclick = () => handleAnswer(ch.isCorrect, word);
                    ui.area.appendChild(btn);
                });

            } else if (qType.includes('typ')) {
                // ... (Typing logic remains same)
                const placeholder = t('input_placeholder') || "Input Answer";
                const submitText = t('submit') || "Submit";
                ui.area.innerHTML = `
            <input type="text" id="quiz-input" placeholder="${placeholder}" autocomplete="off" 
                style="background:rgba(255,255,255,0.1); border:1px solid var(--accent); padding:15px; font-size:1.2rem; text-align:center; border-radius:10px; color:white; width:100%;">
            <button onclick="checkInputAnswer()" class="glass-btn primary" style="margin-top:10px;">${submitText}</button>
        `;
                setTimeout(() => {
                    const input = document.getElementById('quiz-input');
                    if (input) { input.focus(); input.addEventListener("keyup", (e) => { if (e.key === "Enter") checkInputAnswer(); }); }
                }, 100);

            } else if (qType === 'j_wri_chk') {
                // ... (Self check logic remains same)
                const hintText = t('self_check_hint') || "Write it down or think about it.";
                const checkBtnText = t('check_answer') || "Check Answer";
                ui.area.innerHTML = `
            <div id="self-check-step1" style="width:100%;">
                <p style="opacity:0.7; margin-bottom:10px;">${hintText}</p>
                <button onclick="revealSelfCheck()" class="glass-btn" style="border:1px solid var(--accent);">${checkBtnText}</button>
            </div>
            <div id="self-check-step2" style="display:none; text-align:center; width:100%;">
                <h2 style="color:var(--primary); margin-bottom:20px;">${word.term}</h2>
                <div style="display:flex; gap:10px;">
                    <button onclick="handleAnswer(true, null)" class="glass-btn" style="border-color:#4CAF50; color:#4CAF50;">⭕ ${t('correct')}</button>
                    <button onclick="handleAnswer(false, null)" class="glass-btn" style="border-color:var(--danger); color:var(--danger);">❌ ${t('wrong')}</button>
                </div>
            </div>
        `;
            }
        }

        // 5. 정답 처리 로직
        function checkInputAnswer() {
            const input = document.getElementById('quiz-input').value.trim().toLowerCase();
            const word = quizSession.queue[quizSession.cursor];
            const correct = word.term.toLowerCase();
            handleAnswer(input === correct, word);
        }

        function revealSelfCheck() {
            document.getElementById('self-check-step1').style.display = 'none';
            document.getElementById('self-check-step2').style.display = 'block';
        }

        function handleAnswer(isCorrect, wordObj) {
            if (!wordObj) wordObj = quizSession.queue[quizSession.cursor]; // 자가진단용 폴백

            const fb = document.getElementById('q-feedback');
            const title = document.getElementById('fb-title');
            const detail = document.getElementById('fb-detail');
            const nextBtn = document.getElementById('fb-next-btn');

            // UI 동결 (중복클릭 방지)
            const btns = document.querySelectorAll('.choice-btn');
            btns.forEach(b => b.disabled = true);

            // 데이터 업데이트 (word stats)
            if (!wordObj.stats) wordObj.stats = { total: 0, wrong: 0, consecutiveCorrect: 0, lastResult: null, lastWrongType: null };
            wordObj.stats.total++;
            wordObj.stats.lastResult = isCorrect ? 'correct' : 'wrong';

            if (isCorrect) {
                quizSession.correctCnt++;
                wordObj.stats.consecutiveCorrect++;
                wordObj.stats.lastWrongType = null;
                title.innerText = t('quiz_correct');
                title.style.color = "#4CAF50";
            } else {
                wordObj.stats.wrong++;
                wordObj.stats.consecutiveCorrect = 0;
                wordObj.stats.lastWrongType = quizSession.currentQType;
                title.innerText = t('quiz_wrong');
                title.style.color = "var(--danger)";
            }
            nextBtn.innerText = t('quiz_next');
            saveData();

            // ★ [여기 수정됨] 사전 검색 버튼 추가 ★
            // 현재 단어의 언어 코드 가져오기
            const langCode = getCodeByLangId(wordObj.langId);

            detail.innerHTML = `
        <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:5px;">
            <span style="font-size:1.5rem; font-weight:bold; color:var(--text-main);">${wordObj.term}</span>
            <!-- 사전 버튼 추가 -->
            <button class="dict-btn" onclick="openDictWindow('${wordObj.term}', '${langCode}')" 
                    style="font-size:0.8rem; padding:4px 10px;">${t('dict_search')}</button>
        </div>
        ${wordObj.pron ? `<span style="color:var(--accent); display:block; margin-bottom:5px;">${wordObj.pron}</span>` : ''}
        <div style="font-size:1.1rem; font-weight:600; margin-bottom:5px;">${wordObj.mean}</div>
        <span style="font-size:0.85rem; opacity:0.6;">${wordObj.memo || ''}</span>
    `;

            fb.style.display = 'block';
            nextBtn.focus();
        }

        function nextQuestion() {
            quizSession.cursor++;
            showNextQuestion();
        }

        // --- TTS (Voice Init & Speak) ---

        // --- [최종 수정] TTS 시스템 (Only Online Mode) ---

        function speakCurrent() {
            // 퀴즈 진행중일 때 현재 단어 읽기
            if (quizSession.active && quizSession.queue.length > 0) {
                const word = quizSession.queue[quizSession.cursor];
                const langCode = getCodeByLangId(word.langId);

                // 일본어('ja')나 중국어('zh')인 경우, word.pron(후리가나/병음)이 있으면 그것을 읽게 함
                // 그 외 언어거나 발음 정보가 없으면 기존처럼 word.term을 읽음
                const textToSpeak = ((langCode === 'ja' || langCode === 'zh') && word.pron) ? word.pron : word.term;

                speak(textToSpeak, langCode);
            }
        }

        /* --- [수정] speak 함수 (구글 TTS 서버 강제 사용) --- */
        function speak(text, langCode) {
            if (!text) return;

            // 1. 오프라인이어도 일단 시도하도록 로직 변경 (브라우저 캐시 활용 가능성)
            // 2. 언어 코드 매핑 (구글 TTS 표준에 맞춤)
            let tl = langCode;
            if (langCode === 'zh') tl = 'zh-CN';
            else if (langCode === 'ja') tl = 'ja';
            else if (langCode === 'ko') tl = 'ko';
            else if (langCode === 'es') tl = 'es';
            else if (langCode === 'en') tl = 'en';

            // 3. 구글 TTS URL 생성 (client=tw-ob 파라미터가 핵심)
            const encodedText = encodeURIComponent(text);
            const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodedText}&tl=${tl}&client=tw-ob`;

            // 4. 오디오 재생
            const audio = new Audio(url);

            // 모바일 브라우저 호환성을 위해 로드 후 재생
            audio.play().catch(err => {
                console.error("TTS 재생 실패:", err);
                // 만약 구글 서버가 막히면 최후의 수단으로 브라우저 내장 기능 시도
                if (window.speechSynthesis) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = tl;
                    window.speechSynthesis.speak(utterance);
                }
            });
        }


        // --- [Drag & Drop Logic (Unified)] ---

        let draggedItem = null;
        let dragSrcIndex = null;
        let dragType = null; // 'word' or 'group'
        let touchDragItem = null;

        // 1. 드래그 시작
        function dragStart(e) {
            draggedItem = e.target.closest('[data-index]');
            dragSrcIndex = Number(draggedItem.dataset.index);
            dragType = draggedItem.dataset.type; // word 또는 group 식별

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedItem.innerHTML);
            draggedItem.classList.add('dragging');
        }

        // 2. 드래그 오버 (필수)
        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        // 3. 드랍 (통합)
        function dropItem(e) {
            e.stopPropagation();

            // 타겟 아이템 찾기
            const targetItem = e.target.closest('[data-index]');

            // 유효성 검사: 타겟이 있고, 타입이 같고, 제자리가 아닐 때
            if (draggedItem && targetItem &&
                draggedItem !== targetItem &&
                draggedItem.dataset.type === targetItem.dataset.type) {

                const dragDestIndex = Number(targetItem.dataset.index);

                if (dragType === 'word') {
                    reorderWordsData(dragSrcIndex, dragDestIndex);
                } else if (dragType === 'group') {
                    reorderGroupsData(dragSrcIndex, dragDestIndex);
                }
            }

            if (draggedItem) draggedItem.classList.remove('dragging');
            draggedItem = null;
            return false;
        }

        /* [수정 2-1] 순서 변경 후 스크롤 위치 유지 */
        function reorderWordsData(fromIndex, toIndex) {
            const currentGroupWords = appData.words.filter(w => String(w.groupId) === String(currentGroupId));
            if (!currentGroupWords[fromIndex] || !currentGroupWords[toIndex]) return;

            const sourceWord = currentGroupWords[fromIndex];
            const targetWord = currentGroupWords[toIndex];

            const realFromIdx = appData.words.findIndex(w => w.id === sourceWord.id);
            const realToIdx = appData.words.findIndex(w => w.id === targetWord.id);

            if (realFromIdx === -1 || realToIdx === -1) return;

            // 현재 스크롤 위치 저장 (전역 window나 특정 컨테이너)
            const scrollContainer = document.getElementById('scroll-area'); // scroll-area 사용
            const currentScrollY = scrollContainer ? scrollContainer.scrollTop : 0;

            const [movedItem] = appData.words.splice(realFromIdx, 1);
            appData.words.splice(realToIdx, 0, movedItem);

            saveData();

            // 렌더링 호출
            renderGroupDetail(document.getElementById('main-view-area'), movedItem.langId, currentGroupId);

            // 렌더링 직후 스크롤 복구
            // DOM 업데이트 타이밍을 맞추기 위해 setTimeout 사용하지 않고 동기적으로 시도하거나, 
            // 미세한 딜레이를 줄 수 있음. (보통은 렌더링 직후가 안전)
            setTimeout(() => {
                const container = document.getElementById('scroll-area');
                if (container) container.scrollTop = currentScrollY;
            }, 0);
        }


        // 5. 그룹 순서 변경 (데이터)
        function reorderGroupsData(fromIndex, toIndex) {
            // 현재 화면에 보이는 그룹 리스트
            // (renderGroupListNew에서 필터링한 순서와 같아야 함)
            // 만약 renderGroupListNew에서 역순 정렬 등을 하지 않았다면 
            // filter 결과의 인덱스와 화면 인덱스는 일치해야 하지만,
            // 전체 groups 배열에서 해당 언어의 그룹들만 추출해서 작업해야 함.

            // 현재 언어의 모든 그룹 추출
            const currentLangGroups = appData.groups.filter(g => g.langId === currentTab);

            if (!currentLangGroups[fromIndex] || !currentLangGroups[toIndex]) return;

            // 실제 전체 배열 인덱스 찾기
            const realFromIdx = appData.groups.indexOf(currentLangGroups[fromIndex]);
            const realToIdx = appData.groups.indexOf(currentLangGroups[toIndex]);

            // 데이터 이동
            const [movedGroup] = appData.groups.splice(realFromIdx, 1);
            appData.groups.splice(realToIdx, 0, movedGroup);

            saveData();
            // 언어 대시보드 화면 갱신
            renderLanguageView(document.getElementById('main-view-area'), currentTab);
        }

        // 6. 터치 이벤트 (모바일)
        function touchStart(e) {
            // 핸들 터치 시에만 동작
            if (!e.target.classList.contains('drag-handle')) return;

            touchDragItem = e.target.closest('[data-index]');
            if (!touchDragItem) return;

            dragSrcIndex = Number(touchDragItem.dataset.index);
            dragType = touchDragItem.dataset.type;
            touchDragItem.classList.add('dragging');

            // 스크롤 방지용 (필요 시)
            // e.preventDefault(); 
        }

        function touchMove(e) {
            if (!touchDragItem) return;
            e.preventDefault(); // 드래그 중 스크롤 방지
            if (e.cancelable) {
                e.preventDefault();
            }
            // 시각적 효과 추가 가능 (좌표 따라다니기 등)
        }

        function touchEnd(e) {
            if (!touchDragItem) return;

            const changedTouch = e.changedTouches[0];
            // 손가락을 뗀 위치의 요소를 찾음
            const realTarget = document.elementFromPoint(changedTouch.clientX, changedTouch.clientY);

            // 해당 요소가 리스트 아이템인지 확인 (핸들, 텍스트, 빈 공간 등 어디를 놓아도 찾도록 closest 사용)
            const targetItem = realTarget ? realTarget.closest('[data-index]') : null;

            if (targetItem && targetItem !== touchDragItem) {
                // 드래그 시작 타입과 드랍 타입이 같은지 확인
                const currentDragType = touchDragItem.dataset.type;
                const targetDragType = targetItem.dataset.type;

                if (currentDragType === targetDragType) {
                    const destIndex = Number(targetItem.dataset.index);
                    // dragSrcIndex는 전역 변수로 touchStart에서 설정됨
                    if (currentDragType === 'word') {
                        reorderWordsData(dragSrcIndex, destIndex);
                    } else if (currentDragType === 'group') {
                        reorderGroupsData(dragSrcIndex, destIndex);
                    }
                }
            }

            // 초기화
            touchDragItem.classList.remove('dragging');
            touchDragItem = null;
        }




        /* =========================================
           [JS 추가] 초기 설정 마법사 로직
           ========================================= */

        let currentSetupStep = 1;

        // 1. 초기 설정 시작 (window.onload에서 호출됨)
        // 기존 로직을 대체하기 위해 별도 함수로 분리하지 않고, 
        // window.onload 내부의 로직을 아래와 같이 수정해야 함.
        // (하지만 이미 window.onload가 작성되어 있으니, 이 함수들을 추가하고 
        //  window.onload가 이 로직을 탈 수 있게 active 클래스 제어를 아래 initSetup으로 합니다)

        function initSetup() {
            if (appData.config.setupDone) return;

            // [개선] 초기 언어를 강제로 영어(en)로 설정 (첫 실행 시)
            // 기존 데이터가 없거나, 아직 설정을 안 마쳤으면 기본값 en
            if (!localStorage.getItem(STORE_KEY)) {
                appData.config.sysLang = 'en';
            }

            renderSetupModal(); // HTML 생성
            goSetupStep(1);     // 1단계 표시
            openModalWithAnim('setup-popup');
        }


        // 2. 모달 HTML 동적 생성 (언어 변경 즉시 반영을 위해)
        function renderSetupModal() {
            let modal = document.getElementById('setup-popup');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'setup-popup';
                modal.className = 'modal-overlay';
                document.body.appendChild(modal);
            }

            // 로고 경로
            const logoSrc = getLogoSrc();

            // 현재 언어 선택 상태 확인
            const currentLang = appData.config.sysLang;

            modal.innerHTML = `
    <div class="modal-panel">
        <div class="modal-sticky-header" id="setup-header" style="display:none;">
            <button onclick="prevSetupStep()" class="back-icon-btn">←</button>
            <h3 style="margin:0; font-size:1.1rem;">Setup</h3>
            <div style="width:40px;"></div>
        </div>

        <div class="modal-scroll-body" style="padding-top:20px;">
            
            <!-- STEP 1: 환영 인사 -->
            <div id="setup-step-1" class="setup-step">
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh;">
                    <div class="logo-container" style="margin-bottom:30px;">
                        <img src="${logoSrc}" class="app-logo large" id="setup-logo" style="height:320px;">
                    </div>
                    <h1 style="font-size:2rem; margin:0 0 10px 0;" class="liquid-text-gradient">${t('welcome_title')}</h1>
                    <p class="desc">${t('welcome_desc')}</p>
                    
                    <input type="file" id="setup-file-import" style="display:none;" onchange="importSetupData(this)">

                    <button class="glass-btn primary" onclick="goSetupStep(2)" style="margin-top:40px; width:80%;">${t('start')}</button>
                    
                    <button class="glass-btn" onclick="triggerSetupImport()" 
                            style="margin-top:10px; width:80%; background:transparent; border:1px solid var(--text-dim); color:var(--text-dim);">
                        ${t('import_data')}
                    </button>
                </div>
            </div>

            <!-- STEP 2: 언어 설정 -->
            <div id="setup-step-2" class="setup-step hidden">
                <div style="text-align:center; margin-bottom:20px;">
                    <h2 style="margin:0;">${t('setup_lang')}</h2>
                    <p class="desc">${t('setup_lang_desc')}</p>
                </div>

                <div class="glass-card" style="padding:20px; margin-bottom:20px;">
                    <label class="input-label" style="margin-bottom:8px;">${t('mother_tongue')}</label>
                    <select id="setup-sys-lang" onchange="updateSysLang(this.value)" style="margin:0;">
                        <option value="en" ${currentLang === 'en' ? 'selected' : ''}>English</option>
                        <option value="ko" ${currentLang === 'ko' ? 'selected' : ''}>한국어 (Korean)</option>
                        <option value="ja" ${currentLang === 'ja' ? 'selected' : ''}>日本語</option>
                        <option value="zh" ${currentLang === 'zh' ? 'selected' : ''}>中文 (Chinese)</option>
                        <option value="es" ${currentLang === 'es' ? 'selected' : ''}>Español</option>
                    </select>
                </div>

                <label class="input-label" style="margin-left:5px; margin-bottom:10px;">${t('target_lang')}</label>
                <div id="setup-flag-grid" class="flag-grid" style="margin-top:0; padding:0;"></div>

                <div style="height:30px;"></div>
                <button class="glass-btn primary" onclick="goSetupStep(3)">${t('quiz_next')}</button>
            </div>

            <!-- STEP 3: 테마 -->
            <div id="setup-step-3" class="setup-step hidden">
                <div style="text-align:center; margin-bottom:20px;">
                    <h2 style="margin:0;">${t('setup_theme')}</h2>
                    <p class="desc">${t('setup_theme_desc')}</p>
                </div>

                <div style="display:flex; gap:15px; margin-bottom:30px; justify-content:center;">
                    <button class="glass-btn" onclick="previewTheme('dark')" id="btn-setup-dark" style="flex:1; border:2px solid var(--glass-border);">${t('theme_dark')}</button>
                    <button class="glass-btn" onclick="previewTheme('light')" id="btn-setup-light" style="flex:1; border:1px solid var(--glass-border);">${t('theme_light')}</button>
                </div>

                <label class="input-label" style="text-align:center; margin-bottom:10px;">${t('preview')}</label>
                <div class="glass-card word-item" style="padding:15px; display:flex; align-items:center; opacity:1; transform:scale(1);">
                    <div style="width:15px; text-align:center; color:var(--text-dim); font-size:0.9rem;">1</div>
                    <div style="flex:1; margin-left:10px;">
                        <div style="color:var(--text-main); font-weight:600; font-size:1.15rem;">
                            Prism <span style="font-weight:normal; color:var(--accent); font-size:0.85rem; margin-left:5px;">[prɪzəm]</span>
                        </div>
                        <div style="color:var(--text-dim); margin-top:2px; font-size:1rem;">프리즘, 분광</div>
                    </div>
                    <div class="icon-btn" style="width:32px; height:32px; display:flex; align-items:center; justify-content:center;">🔊</div>
                </div>

                <div style="height:50px;"></div>
                <button class="glass-btn primary" onclick="finishSetup()">${t('finish_setup')}</button>
            </div>
            
            <div class="modal-footer-gap"></div>
        </div>
    </div>
    `;

            // 단계 복구 (언어 바뀌어도 현재 단계 유지)
            goSetupStep(currentSetupStep);
        }

        // 2. 단계 이동 함수
        function goSetupStep(step) {
            currentSetupStep = step;
            document.querySelectorAll('.setup-step').forEach(el => el.classList.add('hidden'));
            const target = document.getElementById(`setup-step-${step}`);
            if (target) target.classList.remove('hidden');

            const header = document.getElementById('setup-header');
            if (header) {
                if (step === 1) {
                    header.style.display = 'none';
                } else {
                    header.style.display = 'flex';
                }
            }

            if (step === 2) renderSetupFlags();
            if (step === 3) previewTheme(appData.config.theme);
        }

        function prevSetupStep() {
            if (currentSetupStep > 1) {
                goSetupStep(currentSetupStep - 1);
            }
        }

        // 3. (2단계) 언어 선택 렌더링
        function renderSetupFlags() {
            const container = document.getElementById('setup-flag-grid');
            if (!container) return;

            let html = '';
            Object.keys(SUPPORTED_LANGS).forEach(code => {
                const langInfo = SUPPORTED_LANGS[code];
                const existingLang = appData.myLangs.find(my => my.code === code);
                const isAdded = !!existingLang;
                const isVisible = existingLang ? existingLang.isVisible : false;

                let cardStyle = '';
                // [수정] 번역 키 사용
                let statusText = t('lang_status_add');
                let statusColor = 'var(--text-dim)';

                if (isAdded && isVisible) {
                    cardStyle = 'border: 2px solid var(--primary); background: rgba(255, 143, 205, 0.1);';
                    statusText = t('lang_select'); // 선택됨
                    statusColor = 'var(--primary)';
                }

                html += `
        <div class="flag-option" style="${cardStyle}; width:100%; margin:0;" onclick="toggleSetupLang('${code}')">
            <div class="flag-icon">${langInfo.flag}</div>
            <div class="flag-name" style="font-weight:bold; margin-top:5px;">${langInfo.name}</div>
            <div style="font-size:0.8rem; color:${statusColor}; margin-top:2px;">${statusText}</div>
        </div>`;
            });
            container.innerHTML = html;
        }

        // (2단계) 언어 토글 (설정용)
        function toggleSetupLang(code) {
            const existingIndex = appData.myLangs.findIndex(my => my.code === code);

            if (existingIndex > -1) {
                // 이미 존재하면 ON/OFF 토글
                appData.myLangs[existingIndex].isVisible = !appData.myLangs[existingIndex].isVisible;
            } else {
                // 없으면 새로 추가
                appData.myLangs.push({
                    id: Date.now(),
                    code: code,
                    createdAt: Date.now(),
                    isVisible: true
                });
            }

            saveData();
            renderSetupFlags(); // 웰컴 모달 내부 그리드만 다시 그리기 (다른 모달 안 뜸)
        }

        // 2. [신규] 초기 설정용 데이터 불러오기 트리거
        function triggerSetupImport() {
            document.getElementById('setup-file-import').click();
        }

        // 3. [신규] 초기 설정용 파일 처리
        function importSetupData(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const json = JSON.parse(e.target.result);
                    if (confirm(t('restore_confirm'))) {
                        appData = json;
                        if (!appData.config) appData.config = { theme: 'dark', sysLang: 'ko', setupDone: true };
                        else appData.config.setupDone = true;
                        saveData();
                        location.reload();
                    }
                } catch (err) {
                    alert("File Error");
                }
            };
            reader.readAsText(file);
        }

        // 4. (3단계) 테마 미리보기
        function previewTheme(mode) {
            // 실제 테마 적용 (앱 전체가 변함)
            changeTheme(mode);

            // 버튼 스타일 업데이트
            const btnDark = document.getElementById('btn-setup-dark');
            const btnLight = document.getElementById('btn-setup-light');

            if (mode === 'dark') {
                btnDark.classList.add('theme-selected');
                btnLight.classList.remove('theme-selected');
            } else {
                btnLight.classList.add('theme-selected');
                btnDark.classList.remove('theme-selected');
            }

            // 로고 업데이트 (Step 1의 로고도 같이 바꿔줌)
            const logo = document.getElementById('setup-logo');
            if (logo) logo.src = getLogoSrc();
        }

        /* --- finishSetup 함수 교체 (기존 함수 덮어쓰기) --- */
        function finishSetup() {
            appData.config.setupDone = true;
            saveData();

            closeModal('setup-popup');

            // 메인 화면 렌더링 (사이드바 등 갱신)
            renderApp();
        }


        /* --- [수정] 수동 업데이트 확인 함수 (다국어 적용) --- */
        function checkAppUpdate() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(registration => {
                    registration.update().then(() => {
                        // [수정] 번역 함수 t() 사용
                        alert(t('update_checked'));
                    }).catch(err => {
                        // [수정] 번역 함수 t() 사용
                        alert(t('update_fail'));
                    });
                }).catch(() => {
                    // 혹시 모를 에러 대비
                    alert(t('update_fail'));
                });
            } else {
                // [수정] 번역 함수 t() 사용
                alert(t('sw_unsupported'));
            }
        }

        /* =========================================
           [신규] 단어 검색 시스템
           ========================================= */

        let searchFilter = 'all'; // all, term, mean

        function openSearchModal() {
            // 텍스트 업데이트
            document.getElementById('inp-search-query').placeholder = t('search_placeholder');
            document.getElementById('filter-all').innerText = t('category_all');
            document.getElementById('filter-term').innerText = t('category_term');
            document.getElementById('filter-mean').innerText = t('category_mean');

            // 입력창 초기화 및 필터 초기화
            document.getElementById('inp-search-query').value = '';
            setSearchFilter('all');
            document.getElementById('search-results-list').innerHTML = `<p class="desc" style="text-align:center; margin-top:50px;">🔍</p>`;

            openModalWithAnim('modal-search');

            // 포커스
            setTimeout(() => document.getElementById('inp-search-query').focus(), 150);
        }

        function setSearchFilter(type) {
            searchFilter = type;

            // UI 업데이트
            const buttons = document.querySelectorAll('.search-filter-bar .filter-chip');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`filter-${type}`).classList.add('active');

            // 검색어 있으면 재검색
            const query = document.getElementById('inp-search-query').value;
            if (query.trim().length > 0) runSearch();
        }

        function runSearch() {
            const query = document.getElementById('inp-search-query').value.trim().toLowerCase();
            const container = document.getElementById('search-results-list');

            if (query.length === 0) {
                container.innerHTML = '';
                return;
            }

            // 1. 검색 로직
            const results = appData.words.filter(w => {
                const term = w.term.toLowerCase();
                const mean = w.mean.toLowerCase();

                if (searchFilter === 'all') return term.includes(query) || mean.includes(query);
                if (searchFilter === 'term') return term.includes(query);
                if (searchFilter === 'mean') return mean.includes(query);
                return false;
            });

            // 2. 결과 렌더링
            if (results.length === 0) {
                container.innerHTML = `<p class="desc" style="text-align:center; margin-top:30px;">${t('no_search_results')}</p>`;
                return;
            }

            let html = '';
            results.forEach(w => {
                // 위치 정보 찾기
                const group = appData.groups.find(g => g.id === w.groupId);
                const langInfo = appData.myLangs.find(l => l.id === w.langId);
                const langName = langInfo ? SUPPORTED_LANGS[langInfo.code].name : '?';
                const groupTitle = group ? group.title : '?';

                // 순번 찾기 (해당 그룹 내에서 몇 번째인지)
                // 화면에는 역순으로 보이지만 데이터는 정순. 
                // 화면상의 "위에서 n번째"를 원한다면 reverse 인덱스, 
                // 데이터상의 순서를 원한다면 findIndex. 여기선 편의상 데이터 인덱스+1 사용
                const groupWords = appData.words.filter(wd => wd.groupId === w.groupId);
                const indexInGroup = groupWords.findIndex(wd => wd.id === w.id) + 1;

                // 위치 문자열 (번역 적용)
                const locationStr = t('search_result_info', { l: langName, g: groupTitle, i: indexInGroup });

                html += `
            <div class="search-result-item" onclick="navigateToWord(${w.langId}, '${w.groupId}', ${w.id})">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                    <span style="font-size:1.1rem; font-weight:bold; color:var(--text-main);">${w.term}</span>
                    <span class="location-badge" style="font-size:0.7rem; opacity:0.8;">${langName}</span>
                </div>
                <div style="font-size:0.95rem; color:var(--text-dim); margin-bottom:6px;">${w.mean}</div>
                <div style="font-size:0.75rem; color:var(--accent); opacity:0.8;">
                    📍 ${locationStr}
                </div>
            </div>
        `;
            });

            container.innerHTML = html;
        }

        // [핵심] 검색 결과 클릭 시 해당 위치로 이동
        function navigateToWord(langId, groupId, wordId) {
            // 1. 모달 닫기
            closeModal('modal-search');

            // 2. 탭 이동 (언어 탭)
            if (currentTab !== langId) {
                navigate(langId);
            }

            // 3. 그룹 진입 (비동기 렌더링 고려하여 setTimeout 사용)
            setTimeout(() => {
                // 그룹 진입 함수 호출
                enterGroup(groupId);

                // 4. 해당 단어로 스크롤 및 하이라이트
                setTimeout(() => {
                    const element = document.getElementById(wordId);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // 깜빡임 효과
                        element.style.transition = 'background 0.5s';
                        element.style.background = 'rgba(255, 143, 205, 0.3)'; // Highlight color
                        setTimeout(() => {
                            element.style.background = ''; // 원래대로 복귀 (클래스 스타일 따름)
                        }, 1500);
                    }
                }, 300); // 그룹 렌더링 시간 고려
            }, 100); // 탭 전환 시간 고려
        }


        /* --- [신규] FAB 상태 제어 매니저 --- */
        function updateFabState(state) {
            const wrapper = document.getElementById('main-fab-wrapper');
            if (!wrapper) return;

            // 초기화: 클래스 모두 제거
            wrapper.classList.remove('collapsed', 'hidden');

            if (state === 'home') {
                // 홈: 원형 (검색만)
                wrapper.classList.add('collapsed');
            } else if (state === 'expanded') {
                // 리스트/상세: 알약형 (검색 + 추가)
                // 클래스 없음 (기본 상태)
            } else if (state === 'hidden') {
                // 설정 등: 숨김
                wrapper.classList.add('hidden');
            }
        }




    </script>


    <!-- [신규] 리퀴드 글래스 필터 (SVG) -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" aria-hidden="true">
        <filter id="glass-distortion" x="0%" y="0%" width="100%" height="100%" filterUnits="objectBoundingBox">
            <feTurbulence type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="1" seed="5" result="turbulence" />
            <feComponentTransfer in="turbulence" result="mapped">
                <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
                <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
                <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
            </feComponentTransfer>
            <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />
            <feSpecularLighting in="softMap" surfaceScale="15" specularConstant="1.2" specularExponent="30"
                lighting-color="#fff" result="specLight">
                <fePointLight x="-200" y="-200" z="300" />
            </feSpecularLighting>
            <feComposite in="specLight" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" result="litImage" />
            <feDisplacementMap in="SourceGraphic" in2="softMap" scale="20" xChannelSelector="R" yChannelSelector="G" />
        </filter>
    </svg>

</body>

</html>